#pragma once

#include <nt.h>
#include "ke.h"
#include "mm.h"
#include "ex.h"
#include "ob.h"
#include "cm.h"
#include "io.h"

/* Generated by syssvc-gen.py. Needed by the THREAD struct definition. */
#include <ntos_svc_params_gen.h>

#define NTOS_TCB_CAP			(seL4_CapInitThreadTCB)

#define NTOS_PS_TAG		EX_POOL_TAG('n', 't', 'p', 's')

/*
 * Thread object
 */
typedef struct _THREAD {
    CAP_TREE_NODE TreeNode;	/* Must be first member */
    IPC_ENDPOINT ReplyEndpoint;
    struct _PROCESS *Process;
    PCNODE CSpace;
    LIST_ENTRY ThreadListEntry;	/* List link for the PROCESS object's ThreadList */
    LIST_ENTRY QueuedApcList; /* List of all queued APCs. Note the objects in this
			       * list are the APC objects that have been queued on
			       * this THREAD object (not just registered, but queued
			       * due to, say, timer expiry). */
    LIST_ENTRY TimerApcList; /* List of all registered timer APCs. Note the objects in
			      * this list are the TIMER objects. Note additionally that
			      * the APCs here may or may not be queued (this depends on
			      * whether they have expired). */
    LIST_ENTRY LpcConnectionList; /* List of all queued or connected LPC port connections. */
    PIPC_ENDPOINT SystemServiceEndpoint;
    PIPC_ENDPOINT WdmServiceEndpoint;
    PIPC_ENDPOINT FaultEndpoint;
    PCSTR DebugName;
    PVOID EntryPoint;
    MWORD IpcBufferClientAddr;
    MWORD IpcBufferServerAddr;
    THREAD_PRIORITY CurrentPriority;
    NTDLL_THREAD_INIT_INFO InitInfo;
    BOOLEAN InitialThread;
    BOOLEAN IsrThread; /* TRUE if the thread is an interrupt service thread of a driver */
    BOOLEAN Suspended; /* TRUE if the thread has been suspended due to async await */
    BOOLEAN Alertable; /* TRUE if we can deliver APC to the thread */
    LIST_ENTRY PendingIrpList;	/* List of pending IO packets. The objects of this list
				 * are PENDING_IRP. List entry is PENDING_IRP.Link. */
    LIST_ENTRY ReadyListLink; /* Links all threads that are ready to be resumed. */
    KWAIT_BLOCK RootWaitBlock; /* Master equation to satisfy to unblock the thread. */
    KWAIT_BLOCK TimerWaitBlock;	/* Wait block for the WaitTimer object. */
    TIMER WaitTimer;  /* Timer object used by KeWaitForSingleObject */
    ASYNC_STACK AsyncStack; /* Stack of asynchronous call frames, starting from the service handler */
    ULONG SvcNum;	    /* Saved service number */
    BOOLEAN WdmSvc;	    /* Saved service is WDM service */
    ULONG MsgBufferEnd;	    /* Offset to the end of the message buffer after all parameters
			     * have been marshaled (but before any APC objects are marshaled).*/
    NTSTATUS ExitStatus;    /* Exit status of thread */
    SAVED_SERVICE_PARAMETERS SavedParams;
} THREAD, *PTHREAD;

/*
 * Process object
 */
typedef struct _PROCESS {
    DISPATCHER_HEADER Header;
    BOOLEAN Initialized; /* FALSE when process is first created. TRUE once
			  * the initial thread has been successfully created. */
    LIST_ENTRY ThreadList;
    PCNODE SharedCNode;
    HANDLE_TABLE HandleTable;
    VIRT_ADDR_SPACE VSpace;	/* Virtual address space of the process */
    PMMVAD IpcRegionVad;
    PSECTION ImageSection;
    MWORD ImageVirtualSize;
    MWORD UserExceptionDispatcher; /* Address to dispatch to when an exception occurs. */
    MWORD PebClientAddr;
    LIST_ENTRY ProcessListEntry;
    NTDLL_PROCESS_INIT_INFO InitInfo;
    PIO_DRIVER_OBJECT DriverObject;
    NTSTATUS ExitStatus;	    /* Exit status of process */
    ULONG Cookie;
    NOTIFICATION DpcMutex;
    NOTIFICATION WorkItemMutex;
    ULONG_PTR AffinityMask;
    ULONG_PTR InheritedFromUniqueProcessId;
    ULONG_PTR BasePriority;
} PROCESS, *PPROCESS;

/*
 * System thread object
 *
 * A system thread is a thread of the NTOS Executive root task, usually used
 * for interrupt handling.
 */
typedef struct _SYSTEM_THREAD {
    CAP_TREE_NODE TreeNode;
    IPC_ENDPOINT ReplyEndpoint;
    PIPC_ENDPOINT FaultEndpoint;
    PVOID EntryPoint;
    PCSTR DebugName;
    PVOID TlsBase;	 /* TLS base of the thread's TLS region */
    PVOID IpcBuffer;	 /* Address of the thread's seL4 IPC buffer */
    PVOID StackTop;	 /* Stack of the thread */
    THREAD_PRIORITY CurrentPriority;
} SYSTEM_THREAD, *PSYSTEM_THREAD;

typedef VOID (*PSYSTEM_THREAD_ENTRY)();

FORCEINLINE GLOBAL_HANDLE PsGetProcessId(IN PPROCESS Process)
{
    return OBJECT_TO_GLOBAL_HANDLE(Process);
}

FORCEINLINE GLOBAL_HANDLE PsGetThreadId(IN PTHREAD Thread)
{
    return OBJECT_TO_GLOBAL_HANDLE(Thread);
}

FORCEINLINE CLIENT_ID PsGetClientId(IN PTHREAD Thread)
{
    CLIENT_ID Cid = {
	.UniqueProcess = (HANDLE)PsGetProcessId(Thread->Process),
	.UniqueThread = (HANDLE)PsGetThreadId(Thread)
    };
    return Cid;
}

FORCEINLINE MWORD PsThreadCNodeIndexToGuardedCap(IN MWORD Cap,
						 IN PTHREAD Thread)
{
    assert(Cap);
    assert(Cap < (1ULL << THREAD_PRIVATE_CNODE_LOG2SIZE));
    assert(!PsGetGuardValueOfCap(Cap));
    return (Cap << PROCESS_SHARED_CNODE_LOG2SIZE) |
	PsThreadIdToCSpaceGuard(PsGetThreadId(Thread));
}

/* Flags for PsCreateThread */
#define PS_CREATE_THREAD_SUSPENDED	(1)
#define PS_CREATE_ISR_THREAD		(2)

/* init.c */
NTSTATUS PsInitSystemPhase0();
NTSTATUS PsInitSystemPhase1();
PKUSER_SHARED_DATA PsGetUserSharedData();

/* create.c */
NTSTATUS PsCreateThread(IN PPROCESS Process,
                        IN PCONTEXT ThreadContext,
                        IN PINITIAL_TEB InitialTeb,
                        IN ULONG Flags,
			OUT PTHREAD *pThread);
NTSTATUS PsCreateSystemThread(IN PSYSTEM_THREAD Thread,
			      IN PCSTR DebugName,
			      IN PSYSTEM_THREAD_ENTRY EntryPoint,
			      IN BOOLEAN Suspended);
NTSTATUS PsCreateProcess(IN OPTIONAL PSECTION ImageSection,
			 IN OPTIONAL PIO_DRIVER_OBJECT DriverObject,
			 OUT PPROCESS *pProcess);
NTSTATUS PsResumeThread(IN PTHREAD Thread);
NTSTATUS PsResumeSystemThread(IN PSYSTEM_THREAD Thread);
NTSTATUS PsMapDriverCoroutineStack(IN PPROCESS Process,
				   OUT MWORD *pStackTop);
NTSTATUS PsSetThreadPriority(IN PTHREAD Thread,
			     IN THREAD_PRIORITY Priority);
NTSTATUS PsSetSystemThreadPriority(IN PSYSTEM_THREAD Thread,
				   IN THREAD_PRIORITY Priority);

/* kill.c */
NTSTATUS PsTerminateThread(IN PTHREAD Thread,
    			   IN NTSTATUS ExitStatus);
NTSTATUS PsTerminateSystemThread(IN PSYSTEM_THREAD Thread);
NTSTATUS PsTerminateProcess(IN ASYNC_STATE State,
			    IN PTHREAD Thread,
			    IN PPROCESS Process,
			    IN NTSTATUS ExitStatus);
