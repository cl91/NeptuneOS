#pragma once

#include <nt.h>
#include <services.h>
#include <wdmsvc.h>
#include "ke.h"
#include "ntdef.h"
#include "ob.h"
#include "ex.h"

#define DRIVER_OBJECT_DIRECTORY		"\\Driver"
#define DEVICE_OBJECT_DIRECTORY		"\\Device"
#define FILE_SYSTEM_OBJECT_DIRECTORY	"\\FileSystem"

struct _PROCESS;
struct _IO_FILE_OBJECT;
struct _IO_FILE_CONTROL_BLOCK;
struct _CC_CACHE_MAP;
struct _CC_CACHE_SPACE;

/*
 * Server-side object of the client side DRIVER_OBJECT.
 */
typedef struct _IO_DRIVER_OBJECT {
    PCSTR DriverImagePath;
    PCSTR DriverRegistryPath;
    LIST_ENTRY DriverLink;    /* Links all driver objects currently existing */
    LIST_ENTRY DeviceList;    /* All devices created by this driver */
    struct _PROCESS *DriverProcess;
    struct _THREAD *MainEventLoopThread; /* Main event loop thread of the driver process */
    struct _CC_CACHE_SPACE *CacheSpace; /* Non-NULL if the driver initialized cache support. */
    LIST_ENTRY IoPortList; /* List of all X86 IO ports enabled for this driver */
    LIST_ENTRY IoPacketQueue; /* IO packets queued on this driver object but has not
			       * been processed yet. */
    LIST_ENTRY PendingIoPacketList; /* IO packets that have already been moved to driver
				     * process's incoming IO packet buffer and are waiting
				     * for response from the driver process. Note that the
				     * driver may choose to save this IO packet to its
				     * internal buffer and withhold the response until much
				     * later (say, after several calls to IopRequestIrp).
				     * Therefore this list does NOT in general correspond
				     * to the IO packets in the driver's incoming/outgoing
				     * IO packet buffer. */
    LIST_ENTRY ForwardedIrpList; /* List of IRPs that the driver has forwarded via IoCallDriver.
				  * These include those IRPs generated by the driver process.
				  * The list entry for this list is PENDING_IRP.Link */
    LIST_ENTRY InterruptServiceList; /* List of INTERRUPT_SERVICE */
    KEVENT InitializationDoneEvent; /* Signaled when the client process starts accepting
				     * IO packet */
    KEVENT IoPacketQueuedEvent;	    /* Signaled when an IO packet is queued on the driver
				     * object. */
    MWORD IncomingIoPacketsServerAddr; /* IO Request Packets sent to the driver */
    MWORD IncomingIoPacketsClientAddr;
    MWORD OutgoingIoPacketsServerAddr; /* Driver's IO response packets */
    MWORD OutgoingIoPacketsClientAddr;
    BOOLEAN AddDeviceCalled; /* Windows only calls AddDevice once, when the driver
			      * is loaded by the PnP manager. */
} IO_DRIVER_OBJECT, *PIO_DRIVER_OBJECT;

/*
 * Server-side object of the client side DEVICE_OBJECT
 *
 * IRP flows from higher-level device to lower-level device in a device stack,
 * terminating in the lowest device object, or aka physical device object (PDO).
 *
 *   ------------------
 *   | AttachedDevice |          IRP flow
 *   ------------------             |
 *           |                     \|/
 *          \|/
 *   ------------------
 *   |  DeviceObject  |
 *   ------------------
 *           |
 *          \|/
 *   ------------------
 *   |   AttachedTo   |
 *   ------------------
 */
typedef struct _IO_DEVICE_OBJECT {
    PIO_DRIVER_OBJECT DriverObject;
    LIST_ENTRY DeviceLink; /* Links all devices created by this driver object */
    struct _IO_DEVICE_OBJECT *AttachedDevice; /* Higher device object immediately above */
    struct _IO_DEVICE_OBJECT *AttachedTo; /* Lower device object immediately below */
    struct _DEVICE_NODE *DeviceNode; /* Only PDOs in PnP drivers have this. Otherwise NULL. */
    struct _IO_VOLUME_CONTROL_BLOCK *Vcb; /* Only mounted volume devices can have this. */
    LIST_ENTRY OpenFileList; /* List of opened instances of this device object. */
    IO_DEVICE_INFO DeviceInfo;
    KEVENT MountCompleted; /* Used by the volume mount logic to signal mount completion. */
    BOOLEAN Exclusive;
} IO_DEVICE_OBJECT, *PIO_DEVICE_OBJECT;

/*
 * Volume control block. This structure represents a mounted volume and
 * links the file system volume device object with the underlying storage
 * driver's device object.
 */
typedef struct _IO_VOLUME_CONTROL_BLOCK {
    PIO_DEVICE_OBJECT VolumeDevice; /* Volume device object created by the FS driver. */
    PIO_DEVICE_OBJECT StorageDevice; /* Device object from the underlying storage driver. */
    struct _IO_FILE_CONTROL_BLOCK *VolumeFcb;
    struct _IO_FILE_OBJECT *VolumeFile;
    POBJECT_DIRECTORY Subobjects;
    ULONG ClusterSize;
    BOOLEAN MountInProgress;
} IO_VOLUME_CONTROL_BLOCK, *PIO_VOLUME_CONTROL_BLOCK;

/*
 * Server-side object of the client side FILE_OBJECT. Represents
 * an open instance of a DEVICE_OBJECT.
 */
typedef struct _IO_FILE_OBJECT {
    PIO_DEVICE_OBJECT DeviceObject;
    struct _IO_FILE_CONTROL_BLOCK *Fcb;
    LIST_ENTRY DeviceLink; /* List entry for this->DeviceObject->OpenFileList */
    ULONG64 CurrentOffset; /* Current byte offset that the IO manager maintains */
    PEVENT_OBJECT Event;
    ULONG Flags;
    BOOLEAN ReadAccess;
    BOOLEAN WriteAccess;
    BOOLEAN DeleteAccess;
    BOOLEAN SharedRead;
    BOOLEAN SharedWrite;
    BOOLEAN SharedDelete;
} IO_FILE_OBJECT, *PIO_FILE_OBJECT;

/*
 * File control block. This structure represents an opened on-disk file.
 * All opened instances of the same file shares the same file control block.
 * This structure only exists for file objects that belong to a file system.
 * For file objects created by a (non-FS) device driver, the FCB pointer
 * of the file object is NULL.
 */
typedef struct _IO_FILE_CONTROL_BLOCK {
    PIO_FILE_OBJECT MasterFileObject;
    PCSTR FileName;		/* Owned by this struct. */
    ULONG64 FileSize;
    AVL_TREE FileOffsetMappings; /* AVL tree of FILE_OFFSET_MAPPING. This is not
				  * used for the volume FCB. */
    struct _CC_CACHE_MAP *SharedCacheMap;
    LIST_ENTRY PrivateCacheMaps;
    PDATA_SECTION_OBJECT DataSectionObject;
    PIMAGE_SECTION_OBJECT ImageSectionObject;
    PIO_VOLUME_CONTROL_BLOCK Vcb;
    KEVENT OpenCompleted; /* Signaled when the file open is completed. */
    BOOLEAN OpenInProgress;
    KEVENT WriteCompleted; /* Signaled when the WRITE IRP is completed. */
    BOOLEAN WritePending; /* TRUE if a WRITE IRP for this file is in progress. */
} IO_FILE_CONTROL_BLOCK, *PIO_FILE_CONTROL_BLOCK;

/*
 * Forward declarations.
 */

/* cache.c */
typedef VOID (*PCC_PIN_DATA_CALLBACK)(IN PIO_FILE_CONTROL_BLOCK Fcb,
				      IN ULONG64 FileOffset,
				      IN ULONG64 Length,
				      IN NTSTATUS Status,
				      IN OUT PVOID Context);
typedef VOID (*PCC_CACHE_FLUSHED_CALLBACK)(IN PIO_DEVICE_OBJECT VolumeDevice,
					   IN PIO_FILE_OBJECT FileObject,
					   IN IO_STATUS_BLOCK IoStatus,
					   IN OUT PVOID Context);
NTSTATUS CcInitializeCacheMap(IN PIO_FILE_CONTROL_BLOCK Fcb,
			      IN OPTIONAL PIO_DRIVER_OBJECT DriverObject,
			      OUT OPTIONAL struct _CC_CACHE_MAP **pCacheMap);
VOID CcUninitializeCacheMap(IN PIO_FILE_CONTROL_BLOCK Fcb);
NTSTATUS CcPinData(IN ASYNC_STATE AsyncState,
		   IN struct _THREAD *Thread,
		   IN PIO_FILE_CONTROL_BLOCK Fcb,
		   IN ULONG64 FileOffset,
		   IN ULONG64 Length);
VOID CcPinDataEx(IN PIO_FILE_CONTROL_BLOCK Fcb,
		 IN ULONG64 FileOffset,
		 IN ULONG64 Length,
		 IN BOOLEAN Extend,
		 IN PCC_PIN_DATA_CALLBACK Callback,
		 IN OPTIONAL PVOID Context);
VOID CcUnpinData(IN PIO_FILE_CONTROL_BLOCK Fcb,
		 IN ULONG64 FileOffset,
		 IN ULONG Length);
VOID CcSetDirtyData(IN PIO_DRIVER_OBJECT DriverObject,
		    IN MWORD ViewAddress,
		    IN ULONG64 DirtyBits);
VOID CcFlushCache(IN PIO_DEVICE_OBJECT VolumeDevice,
		  IN PIO_FILE_OBJECT FileObject,
		  IN PCC_CACHE_FLUSHED_CALLBACK IopCacheFlushedCallback,
		  IN OUT PVOID Context);
NTSTATUS CcMapDataEx(IN OPTIONAL PIO_DRIVER_OBJECT DriverObject,
		     IN PIO_FILE_CONTROL_BLOCK Fcb,
		     IN ULONG64 FileOffset,
		     IN ULONG Length,
		     OUT ULONG *MappedLength,
		     OUT PVOID *Buffer,
		     IN BOOLEAN MarkDirty);
NTSTATUS CcCopyReadEx(IN PIO_FILE_CONTROL_BLOCK Fcb,
		      IN ULONG64 FileOffset,
		      IN ULONG64 Length,
		      OUT OPTIONAL ULONG64 *pBytesRead,
		      OUT PVOID Buffer);
NTSTATUS CcCopyWriteEx(IN PIO_FILE_CONTROL_BLOCK Fcb,
		       IN ULONG64 FileOffset,
		       IN ULONG64 Length,
		       OUT OPTIONAL ULONG64 *pBytesWritten,
		       IN PVOID Buffer);
NTSTATUS CcZeroData(IN PIO_FILE_CONTROL_BLOCK Fcb,
		    IN ULONG64 FileOffset,
		    IN ULONG64 Length);

FORCEINLINE NTSTATUS CcMapData(IN PIO_FILE_CONTROL_BLOCK Fcb,
			       IN ULONG64 FileOffset,
			       IN ULONG Length,
			       OUT OPTIONAL ULONG *pMappedLength,
			       OUT PVOID *Buffer)
{
    return CcMapDataEx(NULL, Fcb, FileOffset, Length, pMappedLength, Buffer, FALSE);
}

FORCEINLINE NTSTATUS CcCopyRead(IN PIO_FILE_CONTROL_BLOCK Fcb,
				IN ULONG64 FileOffset,
				IN ULONG64 Length,
				OUT PVOID Buffer)
{
    return CcCopyReadEx(Fcb, FileOffset, Length, NULL, Buffer);
}

FORCEINLINE NTSTATUS CcCopyWrite(IN PIO_FILE_CONTROL_BLOCK Fcb,
				 IN ULONG64 FileOffset,
				 IN ULONG64 Length,
				 IN PVOID Buffer)
{
    return CcCopyWriteEx(Fcb, FileOffset, Length, NULL, Buffer);
}

/* file.c */
NTSTATUS IoCreateDevicelessFile(IN OPTIONAL PCSTR FileName,
				IN OPTIONAL POBJECT ParentDirectory,
				IN OPTIONAL ULONG64 FileSize,
				OUT PIO_FILE_OBJECT *pFile);

/* init.c */
NTSTATUS IoInitSystemPhase0();
NTSTATUS IoInitSystemPhase1();

/*
 * Debug helper functions
 */
VOID IoDbgDumpFileObject(IN PIO_FILE_OBJECT File);
