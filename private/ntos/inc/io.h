#pragma once

#define DRIVER_OBJECT_DIRECTORY		"\\Driver"
#define DEVICE_OBJECT_DIRECTORY		"\\Device"
#define FILE_SYSTEM_OBJECT_DIRECTORY	"\\FileSystem"

struct _PROCESS;
struct _IO_FILE_OBJECT;

/*
 * Server-side object of the client side DRIVER_OBJECT.
 */
typedef struct _IO_DRIVER_OBJECT {
    PCSTR DriverImagePath;
    PCSTR DriverRegistryPath;
    LIST_ENTRY DriverLink;    /* Links all driver objects currently existing */
    LIST_ENTRY DeviceList;    /* All devices created by this driver */
    struct _IO_FILE_OBJECT *DriverFile;
    struct _PROCESS *DriverProcess;   /* TODO: We need to figure out Driver and Mini-driver */
    struct _THREAD *MainEventLoopThread; /* Main event loop thread of the driver process */
    LIST_ENTRY IoPortList; /* List of all X86 IO ports enabled for this driver */
    LIST_ENTRY IoPacketQueue; /* IO packets queued on this driver object but has not been processed yet. */
    LIST_ENTRY PendingIoPacketList; /* IO packets that have already been moved to driver process's
				     * incoming IO packet buffer and are waiting for response from the
				     * driver process. Note that the driver may choose to save this IO
				     * packet to its internal buffer and withhold the response until much
				     * later (say, after several calls to IopRequestIrp). Therefore this
				     * list does NOT in general correspond to the IO packets in the driver's
				     * incoming/outgoing IO packet buffer. */
    LIST_ENTRY ForwardedIrpList; /* List of IRPs that the driver has forwarded via IoCallDriver.
				  * These include those IRPs generated by the driver process.
				  * The list entry for this list is PENDING_IRP.Link */
    LIST_ENTRY InterruptServiceList; /* List of INTERRUPT_SERVICE */
    KEVENT InitializationDoneEvent; /* Signaled when the client process starts accepting IO packet */
    KEVENT IoPacketQueuedEvent;	    /* Signaled when an IO packet is queued on the driver object. */
    MWORD IncomingIoPacketsServerAddr; /* IO Request Packets sent to the driver */
    MWORD IncomingIoPacketsClientAddr;
    MWORD OutgoingIoPacketsServerAddr; /* Driver's IO response packets */
    MWORD OutgoingIoPacketsClientAddr;
    BOOLEAN AddDeviceCalled; /* Windows only calls AddDevice once, when the driver
			      * is loaded by the PnP manager. */
} IO_DRIVER_OBJECT, *PIO_DRIVER_OBJECT;

/*
 * Server-side object of the client side DEVICE_OBJECT
 *
 * IRP flows from higher-level device to lower-level device in a device stack,
 * terminating in the lowest device object, or aka physical device object (PDO).
 *
 *   ------------------
 *   | AttachedDevice |          IRP flow
 *   ------------------             |
 *           |                     \|/
 *          \|/
 *   ------------------
 *   |  DeviceObject  |
 *   ------------------
 *           |
 *          \|/
 *   ------------------
 *   |   AttachedTo   |
 *   ------------------
 */
typedef struct _IO_DEVICE_OBJECT {
    PIO_DRIVER_OBJECT DriverObject;
    LIST_ENTRY DeviceLink; /* Links all devices created by this driver object */
    struct _IO_DEVICE_OBJECT *AttachedDevice; /* Higher device object immediately above */
    struct _IO_DEVICE_OBJECT *AttachedTo; /* Lower device object immediately below */
    struct _DEVICE_NODE *DeviceNode; /* Only PDOs in PnP drivers have this. Otherwise NULL. */
    struct _IO_VOLUME_CONTROL_BLOCK *Vcb; /* Only mounted volume devices can have this. */
    LIST_ENTRY OpenFileList; /* List of opened instances of this device object. */
    POBJECT_DIRECTORY Subobjects;
    IO_DEVICE_INFO DeviceInfo;
    KEVENT MountCompleted; /* Used by the volume mount logic to signal mount completion. */
    BOOLEAN Exclusive;
} IO_DEVICE_OBJECT, *PIO_DEVICE_OBJECT;

/*
 * Volume control block. This structure represents a mounted volume and
 * links the file system volume device object with the underlying storage
 * driver's device object.
 */
typedef struct _IO_VOLUME_CONTROL_BLOCK {
    PIO_DEVICE_OBJECT VolumeDevice; /* Volume device object created by the FS driver. */
    PIO_DEVICE_OBJECT StorageDevice; /* Device object from the underlying storage driver. */
    BOOLEAN MountInProgress;
} IO_VOLUME_CONTROL_BLOCK, *PIO_VOLUME_CONTROL_BLOCK;

/*
 * Server-side object of the client side FILE_OBJECT. Represents
 * an open instance of a DEVICE_OBJECT.
 */
typedef struct _IO_FILE_OBJECT {
    PIO_DEVICE_OBJECT DeviceObject;
    struct _IO_FILE_CONTROL_BLOCK *Fcb;
    LIST_ENTRY DeviceLink; /* List entry for this->DeviceObject->OpenFileList */
    PEVENT_OBJECT Event;
    BOOLEAN ReadAccess;
    BOOLEAN WriteAccess;
    BOOLEAN DeleteAccess;
    BOOLEAN SharedRead;
    BOOLEAN SharedWrite;
    BOOLEAN SharedDelete;
    ULONG Flags;
} IO_FILE_OBJECT, *PIO_FILE_OBJECT;

/*
 * File control block. This structure represents an opened on-disk file.
 * All opened instances of the same file shares the same file control block.
 * This structure only exists for file objects that belong to a file system.
 */
typedef struct _IO_FILE_CONTROL_BLOCK {
    PCSTR FileName;
    MWORD FileSize;
    PVOID BufferPtr;
    PDATA_SECTION_OBJECT DataSectionObject;
    PIMAGE_SECTION_OBJECT ImageSectionObject;
} IO_FILE_CONTROL_BLOCK, *PIO_FILE_CONTROL_BLOCK;

/*
 * Forward declarations.
 */

/* file.c */
NTSTATUS IoCreateDevicelessFile(IN PCSTR FileName,
				IN OPTIONAL POBJECT ParentDirectory,
				IN PVOID BufferPtr,
				IN MWORD FileSize,
				OUT PIO_FILE_OBJECT *pFile);

/* init.c */
NTSTATUS IoInitSystemPhase0();
NTSTATUS IoInitSystemPhase1();
