#pragma once

#include <nt.h>
#include <sel4/sel4.h>
#include <printf.h>
#include "mm.h"

#define NTOS_KE_TAG			(EX_POOL_TAG('n','t','k','e'))

struct _THREAD;

#define LoopOverUntyped(cap, desc, bootinfo)				\
    for (MWORD cap = bootinfo->untyped.start;				\
	 cap < bootinfo->untyped.end; cap++)				\
	for (seL4_UntypedDesc *desc =					\
		 &bootinfo->untypedList[cap - bootinfo->untyped.start]; \
	     desc != NULL; desc = NULL)

/*
 * IPC Endpoint
 */
typedef struct _IPC_ENDPOINT {
    CAP_TREE_NODE TreeNode;
    MWORD Badge;
} IPC_ENDPOINT, *PIPC_ENDPOINT;

#define ENDPOINT_RIGHTS_WRITE_GRANTREPLY	seL4_CapRights_new(1, 0, 0, 1)

static inline VOID KeInitializeIpcEndpoint(IN PIPC_ENDPOINT Self,
					   IN PCNODE CSpace,
					   IN MWORD Cap,
					   IN MWORD Badge)
{
    assert(Self != NULL);
    assert(CSpace != NULL);
    MmInitializeCapTreeNode(&Self->TreeNode, CAP_TREE_NODE_ENDPOINT, Cap,
			    CSpace, NULL);
    Self->Badge = Badge;
}

typedef struct _X86_IOPORT {
    CAP_TREE_NODE TreeNode; /* capability with which to invoke seL4_X86_IOPort_* */
    USHORT PortNum;	    /* port number */
} X86_IOPORT, *PX86_IOPORT;

#define VGA_BLUE			(1)
#define VGA_WHITE			(15)
#define VGA_BG_COLOR			(VGA_BLUE << 4)
#define VGA_FG_COLOR			(VGA_WHITE)
#define VGA_TEXT_COLOR			(VGA_BG_COLOR | VGA_FG_COLOR)

/*
 * Synchronization Primitives
 *
 * A thread can block on a number of kernel objects, collectively known as
 * the dispatcher objects. When a thread blocks on a dispatcher object the
 * system service handler returns STATUS_ASYNC_PENDING and the system
 * service dispatcher saves the reply capability (generated by the seL4
 * microkernel) into the THREAD object, and simply moves on to the next
 * system service message. The thread is effectively suspended until a
 * later time when the NTOS server replies to the saved reply capability.
 *
 * KeWaitForSingleObject() and KeWaitForMultipleObjects() ...
 */
typedef enum _WAIT_TYPE {
    WaitOne,
    WaitAny,
    WaitAll
} WAIT_TYPE;

typedef struct _DISPATCHER_HEADER {
    LIST_ENTRY WaitBlockList;	/* Points to the list of KWAIT_BLOCK chained by its DispatcherLink */
    BOOLEAN Signaled;
} DISPATCHER_HEADER, *PDISPATCHER_HEADER;

static inline VOID KiInitializeDispatcherHeader(IN PDISPATCHER_HEADER Header)
{
    assert(Header != NULL);
    InitializeListHead(&Header->WaitBlockList);
    Header->Signaled = FALSE;
}

/*
 * A wait block represents a boolean condition that is satisfied when a dispatcher
 * object is signaled. Wait blocks form a boolean formula via logical disjunction
 * (or) and logical conjunction (and). In memory this is represented via sub-blocks
 * linked via the SiblingLink of the SubBlockList of the parent wait block. The
 * WaitType determines whether a given wait block is a conjunction (WaitAll) of its
 * sub-blocks or a disjunction (WaitAny) of its sub-blocks. For a leaf-node wait
 * block, the WaitType is WaitOne and the SubBlockList is replaced by DispatcherLink
 * which chains all wait blocks satisfied by a given dispatcher object.
 *
 * The root wait block of the THREAD object represents the master boolean formula
 * that must be satisfied for the thread to wake up. Once it is satisfied, the system
 * service dispatcher will invoke the reply capability stored in the THREAD object
 * to resume the thread.
 */
typedef struct _KWAIT_BLOCK {
    struct _THREAD *Thread;
    WAIT_TYPE WaitType;	/* For WaitOne, the union below is DispatcherLink. */
    union {
	LIST_ENTRY SubBlockList; /* Chains all sub-blocks via SiblingLink */
	LIST_ENTRY DispatcherLink; /* List entry for DISPATCHER_HEADER.WaitBlockList */
    };
    LIST_ENTRY SiblingLink; /* List entry for KWAIT_BLOCK.SubBlockList */
    BOOLEAN Satisfied; /* Initially FALSE. TRUE when the dispatcher object is signaled. */
} KWAIT_BLOCK, *PKWAIT_BLOCK;

/*
 * A kernel event is simply a dispatcher header.
 *
 * Note: you may wonder why we didn't call it "Executive" Event, since we are
 * in the NTOS executive. The reason is to match WinNT/ReactOS. Additionally,
 * for both the original Windows design and our seL4-based NTOS, the ke component
 * is supposed to be a thin wrapper around native hardward constructs (or seL4
 * constructs in our case), and the ex component contains objects that are
 * implemented using primitives in ke. Since KEVENT is simply a small header,
 * it belongs to ke more than it does ex.
 */
typedef struct _KEVENT {
    DISPATCHER_HEADER Header;
    EVENT_TYPE EventType;
} KEVENT, *PKEVENT;

static inline VOID KeInitializeEvent(IN PKEVENT Event,
				     IN EVENT_TYPE EventType)
{
    assert(Event != NULL);
    KiInitializeDispatcherHeader(&Event->Header);
    Event->EventType = EventType;
}

/* async.c */
NTSTATUS KeWaitForSingleObject(IN struct _THREAD *Thread,
			       IN PDISPATCHER_HEADER DispatcherObject);

/* bugcheck.c */
VOID KeBugCheckMsg(IN PCSTR Format, ...);

VOID KeBugCheck(IN PCSTR Function,
		IN PCSTR File,
		IN ULONG Line,
		IN ULONG Error);

#define BUGCHECK_IF_ERR(Expr)	{NTSTATUS Error = (Expr); if (!NT_SUCCESS(Error)) { \
	    KeBugCheck(__func__, __FILE__, __LINE__, Error);}}

/* event.c */
VOID KeSetEvent(IN PKEVENT Event);

/* services.c */
struct _IO_DRIVER_OBJECT;
NTSTATUS KeEnableSystemServices(IN struct _THREAD *Thread);
NTSTATUS KeEnableHalServices(IN struct _THREAD *Thread);

/* port.c */
NTSTATUS KeEnableIoPortX86(IN PCNODE CSpace,
			   IN USHORT PortNum,
			   IN PX86_IOPORT IoPort);

/* vga.c */
VOID KeVgaWriteStringEx(UCHAR Color, PCSTR String);

static inline VOID KeVgaWriteString(PCSTR String)
{
    KeVgaWriteStringEx(VGA_TEXT_COLOR, String);
}

static inline __attribute__((format(printf, 1, 2))) VOID KeVgaPrint(PCSTR Format, ...)
{
    char buf[512];
    va_list arglist;
    va_start(arglist, Format);
    vsnprintf(buf, sizeof(buf), Format, arglist);
    va_end(arglist);
    KeVgaWriteString(buf);
}

/* ../tests/tests.c */
VOID KeRunAllTests();

/* Generated by syssvc-gen.py */
#include <ntos_syssvc_gen.h>
#include <ntos_halsvc_gen.h>
