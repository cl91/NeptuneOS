/*
 * PROJECT:         ReactOS ACPI bus driver
 * FILE:            acpi/ospm/acpienum.c
 * PURPOSE:         ACPI namespace enumerator
 * PROGRAMMERS:     Casper S. Hornstrup (chorns@users.sourceforge.net)
 * UPDATE HISTORY:
 *      01-05-2001  CSH  Created
 */

#include "../precomp.h"
#include "acpi_bus.h"
#include <stdio.h>

#define HAS_CHILDREN(d) ((d)->children.Flink != &((d)->children))
#define HAS_SIBLINGS(d) (((d)->parent) && ((d)->node.Flink != &(d)->parent->children))
#define NODE_TO_DEVICE(n) (CONTAINING_RECORD(n, struct acpi_device, node))

extern struct acpi_device *acpi_root;

static VOID Bus_InitializePdo(PDEVICE_OBJECT Pdo, PFDO_DEVICE_DATA FdoData)
{
    PPDO_DEVICE_DATA pdoData;
    int acpistate;
    DEVICE_POWER_STATE ntState;

    pdoData = (PPDO_DEVICE_DATA)Pdo->DeviceExtension;

    DPRINT("pdo 0x%p, extension 0x%p\n", Pdo, pdoData);

    if (pdoData->AcpiHandle)
	acpi_bus_get_power(pdoData->AcpiHandle, &acpistate);
    else
	acpistate = ACPI_STATE_D0;

    switch (acpistate) {
    case ACPI_STATE_D0:
	ntState = PowerDeviceD0;
	break;
    case ACPI_STATE_D1:
	ntState = PowerDeviceD1;
	break;
    case ACPI_STATE_D2:
	ntState = PowerDeviceD2;
	break;
    case ACPI_STATE_D3:
	ntState = PowerDeviceD3;
	break;
    default:
	DPRINT1("Unknown power state (%d) returned by acpi\n", acpistate);
	ntState = PowerDeviceUnspecified;
	break;
    }

    //
    // Initialize the rest
    //
    pdoData->Common.IsFDO = FALSE;
    pdoData->Common.Self = Pdo;

    pdoData->ParentFdo = FdoData->Common.Self;

    INITIALIZE_PNP_STATE(pdoData->Common);

    pdoData->Common.DevicePowerState = ntState;
    pdoData->Common.SystemPowerState = FdoData->Common.SystemPowerState;

    InsertTailList(&FdoData->ListOfPDOs, &pdoData->Link);
    FdoData->NumPDOs++;

    // This should be the last step in initialization.
    Pdo->Flags &= ~DO_DEVICE_INITIALIZING;
}

static NTSTATUS Bus_DestroyPdo(PDEVICE_OBJECT Device, PPDO_DEVICE_DATA PdoData)
{
    //
    // BusEnum does not queue any irps at this time so we have nothing to do.
    //

    //
    // Free any resources.
    //

    if (PdoData->HardwareIDs) {
	ExFreePoolWithTag(PdoData->HardwareIDs, 'DpcA');
	PdoData->HardwareIDs = NULL;
    }

    DPRINT("\tDeleting PDO: 0x%p\n", Device);
    IoDeleteDevice(Device);
    return STATUS_SUCCESS;
}

static NTSTATUS Bus_PlugInDevice(struct acpi_device *Device, PFDO_DEVICE_DATA FdoData)
{
    PDEVICE_OBJECT pdo;
    PPDO_DEVICE_DATA pdoData;
    NTSTATUS status;
    ULONG index;
    WCHAR temp[256];
    PLIST_ENTRY entry;

    /* Don't enumerate the root device */
    if (Device->handle == ACPI_ROOT_OBJECT)
	return STATUS_SUCCESS;

    /* Check we didnt add this already */
    for (entry = FdoData->ListOfPDOs.Flink; entry != &FdoData->ListOfPDOs;
	 entry = entry->Flink) {
	struct acpi_device *CurrentDevice;

	pdoData = CONTAINING_RECORD(entry, PDO_DEVICE_DATA, Link);

	//dont duplicate devices
	if (pdoData->AcpiHandle == Device->handle)
	    return STATUS_SUCCESS;

	//check everything but fixed feature devices
	if (pdoData->AcpiHandle)
	    acpi_bus_get_device(pdoData->AcpiHandle, &CurrentDevice);
	else
	    continue;

	//check if the HID matches
	if (!strcmp(Device->pnp.hardware_id, CurrentDevice->pnp.hardware_id)) {
	    //check if UID exists for both and matches
	    if (Device->flags.unique_id && CurrentDevice->flags.unique_id &&
		!strcmp(Device->pnp.unique_id, CurrentDevice->pnp.unique_id)) {
		/* We have a UID on both but they're the same so we have to ignore it */
		DPRINT1("Detected duplicate device: %hs %hs\n", Device->pnp.hardware_id,
			Device->pnp.unique_id);
		return STATUS_SUCCESS;
	    } else if (!Device->flags.unique_id && !CurrentDevice->flags.unique_id) {
		/* No UID so we can only legally have 1 of these devices */
		DPRINT1("Detected duplicate device: %hs\n", Device->pnp.hardware_id);
		return STATUS_SUCCESS;
	    }
	}
    }

    DPRINT("Exposing PDO\n"
	   "======AcpiHandle:   %p\n"
	   "======HardwareId:     %s\n",
	   Device->handle, Device->pnp.hardware_id);

    //
    // Create the PDO
    //

    DPRINT("FdoData->NextLowerDriver = 0x%p\n", FdoData->NextLowerDriver);

    status = IoCreateDevice(FdoData->Common.Self->DriverObject, sizeof(PDO_DEVICE_DATA),
			    NULL, FILE_DEVICE_CONTROLLER, FILE_AUTOGENERATED_DEVICE_NAME,
			    FALSE, &pdo);

    if (!NT_SUCCESS(status)) {
	return status;
    }

    pdoData = (PPDO_DEVICE_DATA)pdo->DeviceExtension;
    pdoData->AcpiHandle = Device->handle;

    //
    // Copy the hardware IDs
    //
    index = 0;
    index += swprintf(&temp[index], L"ACPI\\%hs", Device->pnp.hardware_id);
    temp[index++] = UNICODE_NULL;

    index += swprintf(&temp[index], L"*%hs", Device->pnp.hardware_id);
    temp[index++] = UNICODE_NULL;
    temp[index++] = UNICODE_NULL;

    pdoData->HardwareIDs = ExAllocatePoolWithTag(index * sizeof(WCHAR),
						 'DpcA');

    if (!pdoData->HardwareIDs) {
	IoDeleteDevice(pdo);
	return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(pdoData->HardwareIDs, temp, index * sizeof(WCHAR));
    Bus_InitializePdo(pdo, FdoData);

    return status;
}

/* looks alot like acpi_bus_walk doesnt it */
NTSTATUS Bus_EnumerateDevices(PFDO_DEVICE_DATA DeviceExtension)
{
    ULONG Count = 0;
    struct acpi_device *Device = acpi_root;

    while (Device) {
	if (Device->status.present && Device->status.enabled &&
	    Device->flags.hardware_id) {
	    Bus_PlugInDevice(Device, DeviceExtension);
	    Count++;
	}

	if (HAS_CHILDREN(Device)) {
	    Device = NODE_TO_DEVICE(Device->children.Flink);
	    continue;
	}
	if (HAS_SIBLINGS(Device)) {
	    Device = NODE_TO_DEVICE(Device->node.Flink);
	    continue;
	}
	while ((Device = Device->parent)) {
	    if (HAS_SIBLINGS(Device)) {
		Device = NODE_TO_DEVICE(Device->node.Flink);
		break;
	    }
	}
    }
    DPRINT("acpi device count: %d\n", Count);
    return STATUS_SUCCESS;
}
