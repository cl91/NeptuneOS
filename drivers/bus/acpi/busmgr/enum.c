/*
 * PROJECT:         ReactOS ACPI bus driver
 * FILE:            acpi/ospm/acpienum.c
 * PURPOSE:         ACPI namespace enumerator
 * PROGRAMMERS:     Casper S. Hornstrup (chorns@users.sourceforge.net)
 * UPDATE HISTORY:
 *      01-05-2001  CSH  Created
 */

#include "../precomp.h"
#include "acpi_bus.h"
#include <stdio.h>

#define HAS_CHILDREN(d) ((d)->Children.Flink != &((d)->Children))
#define HAS_SIBLINGS(d) (((d)->Parent) && ((d)->Node.Flink != &(d)->Parent->Children))
#define NODE_TO_DEVICE(n) (CONTAINING_RECORD(n, ACPI_DEVICE, Node))

extern PACPI_DEVICE AcpiRoot;

static VOID Bus_InitializePdo(PDEVICE_OBJECT Pdo, PFDO_DEVICE_DATA FdoData)
{
    PAGED_CODE();
    PPDO_DEVICE_DATA PdoData;
    INT AcpiState;
    DEVICE_POWER_STATE PowerState;

    PdoData = (PPDO_DEVICE_DATA)Pdo->DeviceExtension;

    DPRINT("pdo %p, extension %p\n", Pdo, PdoData);

    if (PdoData->AcpiHandle)
	AcpiBusGetPower(PdoData->AcpiHandle, &AcpiState);
    else
	AcpiState = ACPI_STATE_D0;

    switch (AcpiState) {
    case ACPI_STATE_D0:
	PowerState = PowerDeviceD0;
	break;
    case ACPI_STATE_D1:
	PowerState = PowerDeviceD1;
	break;
    case ACPI_STATE_D2:
	PowerState = PowerDeviceD2;
	break;
    case ACPI_STATE_D3:
	PowerState = PowerDeviceD3;
	break;
    default:
	DPRINT1("Unknown power state (%d) returned by acpi\n", AcpiState);
	PowerState = PowerDeviceUnspecified;
	break;
    }

    //
    // Initialize the rest
    //
    PdoData->Common.IsFDO = FALSE;
    PdoData->Common.Self = Pdo;

    PdoData->ParentFdo = FdoData->Common.Self;

    INITIALIZE_PNP_STATE(PdoData->Common);

    PdoData->Common.DevicePowerState = PowerState;
    PdoData->Common.SystemPowerState = FdoData->Common.SystemPowerState;

    InsertTailList(&FdoData->ListOfPDOs, &PdoData->Link);
    FdoData->NumPDOs++;

    // This should be the last step in initialization.
    Pdo->Flags &= ~DO_DEVICE_INITIALIZING;
}

static NTSTATUS Bus_DestroyPdo(PDEVICE_OBJECT Device, PPDO_DEVICE_DATA PdoData)
{
    PAGED_CODE();
    //
    // BusEnum does not queue any irps at this time so we have nothing to do.
    //

    //
    // Free any resources.
    //

    if (PdoData->HardwareIDs) {
	ExFreePoolWithTag(PdoData->HardwareIDs, 'DpcA');
	PdoData->HardwareIDs = NULL;
    }

    DPRINT("\tDeleting PDO: %p\n", Device);
    IoDeleteDevice(Device);
    return STATUS_SUCCESS;
}

static NTSTATUS Bus_PlugInDevice(PACPI_DEVICE Device, PFDO_DEVICE_DATA FdoData)
{
    PAGED_CODE();
    PDEVICE_OBJECT Pdo;
    PPDO_DEVICE_DATA PdoData;
    NTSTATUS Status;
    ULONG Index;
    WCHAR Temp[256];
    PLIST_ENTRY Entry;

    /* Don't enumerate the root device */
    if (Device->Handle == ACPI_ROOT_OBJECT)
	return STATUS_SUCCESS;

    /* Check we didnt add this already */
    for (Entry = FdoData->ListOfPDOs.Flink; Entry != &FdoData->ListOfPDOs;
	 Entry = Entry->Flink) {
	PACPI_DEVICE CurrentDevice;

	PdoData = CONTAINING_RECORD(Entry, PDO_DEVICE_DATA, Link);

	//dont duplicate devices
	if (PdoData->AcpiHandle == Device->Handle)
	    return STATUS_SUCCESS;

	//check everything but fixed feature devices
	if (PdoData->AcpiHandle)
	    AcpiBusGetDevice(PdoData->AcpiHandle, &CurrentDevice);
	else
	    continue;

	//check if the HID matches
	if (!strcmp(Device->Pnp.HardwareId, CurrentDevice->Pnp.HardwareId)) {
	    //check if UID exists for both and matches
	    if (Device->Flags.UniqueId && CurrentDevice->Flags.UniqueId &&
		!strcmp(Device->Pnp.UniqueId, CurrentDevice->Pnp.UniqueId)) {
		/* We have a UID on both but they're the same so we have to ignore it */
		DPRINT1("Detected duplicate device: %hs %hs\n", Device->Pnp.HardwareId,
			Device->Pnp.UniqueId);
		return STATUS_SUCCESS;
	    } else if (!Device->Flags.UniqueId && !CurrentDevice->Flags.UniqueId) {
		/* No UID so we can only legally have 1 of these devices */
		DPRINT1("Detected duplicate device: %hs\n", Device->Pnp.HardwareId);
		return STATUS_SUCCESS;
	    }
	}
    }

    DPRINT("Exposing PDO\n======AcpiHandle:   %p\n======HardwareId:     %s\n",
	   Device->Handle, Device->Pnp.HardwareId);

    //
    // Create the PDO
    //

    DPRINT("FdoData->NextLowerDriver = %p\n", FdoData->NextLowerDriver);

    Status = IoCreateDevice(FdoData->Common.Self->DriverObject, sizeof(PDO_DEVICE_DATA),
			    NULL, FILE_DEVICE_CONTROLLER, FILE_AUTOGENERATED_DEVICE_NAME,
			    FALSE, &Pdo);

    if (!NT_SUCCESS(Status)) {
	return Status;
    }

    PdoData = (PPDO_DEVICE_DATA)Pdo->DeviceExtension;
    PdoData->AcpiHandle = Device->Handle;

    //
    // Copy the hardware IDs
    //
    Index = 0;
    Index += swprintf(&Temp[Index], L"ACPI\\%hs", Device->Pnp.HardwareId);
    Temp[Index++] = UNICODE_NULL;

    Index += swprintf(&Temp[Index], L"*%hs", Device->Pnp.HardwareId);
    Temp[Index++] = UNICODE_NULL;
    Temp[Index++] = UNICODE_NULL;

    PdoData->HardwareIDs = ExAllocatePoolWithTag(NonPagedPool, Index * sizeof(WCHAR),
						 'DpcA');

    if (!PdoData->HardwareIDs) {
	IoDeleteDevice(Pdo);
	return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(PdoData->HardwareIDs, Temp, Index * sizeof(WCHAR));
    Bus_InitializePdo(Pdo, FdoData);

    return Status;
}

/* looks alot like acpi_bus_walk doesnt it */
NTSTATUS Bus_EnumerateDevices(PFDO_DEVICE_DATA DeviceExtension)
{
    DPRINT1("Enumerating ACPI bus\n");
    ULONG Count = 0;
    PACPI_DEVICE Device = AcpiRoot;

    while (Device) {
	if (Device->Status.Present && Device->Status.Enabled &&
	    Device->Flags.HardwareId) {
	    Bus_PlugInDevice(Device, DeviceExtension);
	    Count++;
	}

	if (HAS_CHILDREN(Device)) {
	    Device = NODE_TO_DEVICE(Device->Children.Flink);
	    continue;
	}
	if (HAS_SIBLINGS(Device)) {
	    Device = NODE_TO_DEVICE(Device->Node.Flink);
	    continue;
	}
	while ((Device = Device->Parent)) {
	    if (HAS_SIBLINGS(Device)) {
		Device = NODE_TO_DEVICE(Device->Node.Flink);
		break;
	    }
	}
    }
    DPRINT("acpi device count: %d\n", Count);
    return STATUS_SUCCESS;
}
