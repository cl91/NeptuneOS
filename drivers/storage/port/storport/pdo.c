/*
 * PROJECT:     ReactOS Storport Driver
 * LICENSE:     GPL-2.0+ (https://spdx.org/licenses/GPL-2.0+)
 * PURPOSE:     Storport PDO code
 * COPYRIGHT:   Copyright 2017 Eric Kohl (eric.kohl@reactos.org)
 */

/* INCLUDES *******************************************************************/

#include "precomp.h"
#include <srbhelper.h>

/* FUNCTIONS ******************************************************************/

NTSTATUS PortCreatePdo(_In_ PFDO_DEVICE_EXTENSION FdoDeviceExtension,
		       _In_ ULONG Bus,
		       _In_ ULONG Target,
		       _In_ ULONG Lun,
		       _Out_ PPDO_DEVICE_EXTENSION *PdoDeviceExtension)
{
    PPDO_DEVICE_EXTENSION DeviceExtension = NULL;
    PDEVICE_OBJECT Pdo = NULL;
    NTSTATUS Status;

    DPRINT("PortCreatePdo(%p %p)\n", FdoDeviceExtension, PdoDeviceExtension);

    /* Create the port device */
    Status = IoCreateDevice(FdoDeviceExtension->Device->DriverObject,
			    sizeof(PDO_DEVICE_EXTENSION), NULL, FILE_DEVICE_MASS_STORAGE,
			    FILE_DEVICE_SECURE_OPEN | FILE_AUTOGENERATED_DEVICE_NAME |
			    DO_DIRECT_IO | DO_POWER_PAGABLE,
			    FALSE, &Pdo);
    if (!NT_SUCCESS(Status)) {
	DPRINT1("IoCreateDevice() failed (Status 0x%X)\n", Status);
	return Status;
    }

    DeviceExtension = (PPDO_DEVICE_EXTENSION)Pdo->DeviceExtension;
    RtlZeroMemory(DeviceExtension, sizeof(PDO_DEVICE_EXTENSION));

    DeviceExtension->ExtensionType = PdoExtension;

    DeviceExtension->Device = Pdo;
    DeviceExtension->FdoExtension = FdoDeviceExtension;
    DeviceExtension->PnpState = dsStopped;
    KeInitializeEvent(&DeviceExtension->QueueUnfrozen, SynchronizationEvent, TRUE);

    /* Add the PDO to the PDO list*/
    InsertHeadList(&FdoDeviceExtension->PdoListHead, &DeviceExtension->PdoListEntry);
    FdoDeviceExtension->PdoCount++;

    DeviceExtension->Bus = Bus;
    DeviceExtension->Target = Target;
    DeviceExtension->Lun = Lun;

    // FIXME: More initialization

    /* The device has been initialized */
    Pdo->Flags &= ~DO_DEVICE_INITIALIZING;

    *PdoDeviceExtension = DeviceExtension;

    return STATUS_SUCCESS;
}

NTSTATUS PortDeletePdo(_In_ PPDO_DEVICE_EXTENSION PdoExtension)
{
    DPRINT("PortDeletePdo(%p)\n", PdoExtension);

    /* Remove the PDO from the PDO list */
    RemoveEntryList(&PdoExtension->PdoListEntry);
    PdoExtension->FdoExtension->PdoCount--;

    if (PdoExtension->InquiryBuffer) {
	ExFreePoolWithTag(PdoExtension->InquiryBuffer, TAG_INQUIRY_DATA);
	PdoExtension->InquiryBuffer = NULL;
    }

    KeClearEvent(&PdoExtension->QueueUnfrozen);

    // FIXME: More uninitialization

    /* Delete the PDO */
    IoDeleteDevice(PdoExtension->Device);

    return STATUS_SUCCESS;
}

static NTSTATUS SrbStatusToNtStatus(IN UCHAR SrbStatus)
{
    switch (SRB_STATUS(SrbStatus)) {
    case SRB_STATUS_SUCCESS:
	return STATUS_SUCCESS;
    case SRB_STATUS_BUSY:
	return STATUS_DEVICE_BUSY;
    case SRB_STATUS_INVALID_LUN:
    case SRB_STATUS_INVALID_TARGET_ID:
    case SRB_STATUS_NO_DEVICE:
    case SRB_STATUS_NO_HBA:
	return STATUS_DEVICE_DOES_NOT_EXIST;
    case SRB_STATUS_COMMAND_TIMEOUT:
    case SRB_STATUS_TIMEOUT:
	return STATUS_IO_TIMEOUT;
    case SRB_STATUS_SELECTION_TIMEOUT:
	return STATUS_DEVICE_NOT_CONNECTED;
    case SRB_STATUS_BAD_FUNCTION:
    case SRB_STATUS_BAD_SRB_BLOCK_LENGTH:
	return STATUS_INVALID_DEVICE_REQUEST;
    case SRB_STATUS_DATA_OVERRUN:
	return STATUS_BUFFER_OVERFLOW;
    default:
	return STATUS_IO_DEVICE_ERROR;
    }
}

VOID PortCompleteRequest(IN PSTORAGE_REQUEST_BLOCK Srb)
{
    PSRB_PORT_CONTEXT Ctx = Srb->PortContext;
    if (!Ctx) {
	return;
    }
    PIRP Irp = Ctx->Irp;
    assert(Irp);
    Irp->IoStatus.Status = SrbStatusToNtStatus(Srb->SrbStatus);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    if (Ctx->DeallocateMdl) {
	assert(Ctx->Mdl);
	IoFreeMdl(Ctx->Mdl);
    }
    if (Ctx->SgList) {
	HalPutScatterGatherList(Ctx->DmaAdapter, Ctx->SgList, Ctx->WriteToDevice);
    }
    ExFreePoolWithTag(Ctx, TAG_PORT_CONTEXT);
    Srb->PortContext = NULL;
    assert(Srb->MiniportContext);
    ExFreePoolWithTag(Srb->MiniportContext, TAG_SRB_EXTENSION);
    Srb->MiniportContext = NULL;
}

/*
 * Set the scatter-gather list in the SRB_PORT_CONTEXT and call the
 * BuildIo and StartIo routines of the miniport.
 */
static NTAPI VOID PortStartMiniportIo(IN PDEVICE_OBJECT DeviceObject,
				      IN PSCATTER_GATHER_LIST SgList,
				      IN PVOID Context)
{
    PSRB_PORT_CONTEXT Ctx = Context;
    PSTORAGE_REQUEST_BLOCK Srb = Ctx->Srb;
    assert(Srb);
    assert(!Srb->PortContext);
    Srb->PortContext = Ctx;
    Ctx->SgList = SgList;
    PFDO_DEVICE_EXTENSION FdoExt = DeviceObject->DeviceExtension;
    assert(FdoExt->ExtensionType == FdoExtension);
    PMINIPORT Miniport = &FdoExt->Miniport;
    PHW_INITIALIZATION_DATA InitData = Miniport->InitData;
    assert(InitData);
    assert(InitData->HwBuildIo);
    assert(InitData->HwStartIo);
    assert(Srb->MiniportContext);
    if (!MiniportBuildIo(Miniport, Srb) || !MiniportStartIo(Miniport, Srb)) {
	Srb->SrbStatus = SRB_STATUS_ERROR;
	PortCompleteRequest(Srb);
    }
}

/*
 * If the device is busy, queue the IRP. Otherwise, start the IO processing.
 */
static NTSTATUS PortStartPacket(IN OUT PPDO_DEVICE_EXTENSION PdoExt,
				IN OUT PIRP Irp,
				IN OUT PSTORAGE_REQUEST_BLOCK Srb)
{
    assert(!Srb->PortContext);
    BOOLEAN QueueFrozen = PdoExt->QueueFrozen;
    if (Srb->SrbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE) {
	/* Start IO directly without waiting for the queue to be unfrozen. */
	QueueFrozen = FALSE;
    }
    /* TODO: We need to use a device queue to save resources. Queuing on a KEVENT
     * is resource intensive since each suspended IRP takes a full coroutine stack. */
    if (QueueFrozen) {
	KeWaitForSingleObject(&PdoExt->QueueUnfrozen, Executive, KernelMode, FALSE, NULL);
    }
    /* Allocate a SRB_PORT_CONTEXT and build the scatter-gather list from the MDL.
     * If the MDL is not set (but SRB has a data buffer), build one. */
    PSRB_PORT_CONTEXT Ctx = ExAllocatePoolWithTag(NonPagedPool,
						  sizeof(SRB_PORT_CONTEXT),
						  TAG_PORT_CONTEXT);
    if (!Ctx) {
	return STATUS_INSUFFICIENT_RESOURCES;
    }
    Ctx->Srb = Srb;
    Ctx->Irp = Irp;
    Ctx->DeallocateMdl = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;
    if (Irp->MdlAddress) {
	Ctx->Mdl = Irp->MdlAddress;
    } else if (Srb->DataBuffer) {
	Ctx->Mdl = IoAllocateMdl(Srb->DataBuffer, Srb->DataTransferLength);
	if (!Ctx->Mdl) {
	    ULONG64 PhyAddr = MmGetPhysicalAddress(Srb->DataBuffer).QuadPart;
	    Status = PhyAddr ? STATUS_INSUFFICIENT_RESOURCES : STATUS_INVALID_ADDRESS;
	    goto done;
	}
	Ctx->DeallocateMdl = TRUE;
    }
    assert(!Ctx->Srb->MiniportContext);
    ULONG SrbExtensionSize = PdoExt->FdoExtension->Miniport.InitData->SrbExtensionSize;
    Ctx->Srb->MiniportContext = ExAllocatePoolWithTag(CachedDmaPool,
						      SrbExtensionSize,
						      TAG_SRB_EXTENSION);
    if (!Ctx->Srb->MiniportContext) {
	goto done;
    }
    PDMA_ADAPTER DmaAdapter = PdoExt->FdoExtension->DmaAdapter;
    assert(DmaAdapter);
    if (Ctx->Mdl) {
	BOOLEAN WriteToDevice = TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_DATA_OUT);
	Ctx->DmaAdapter = DmaAdapter;
	Ctx->WriteToDevice = WriteToDevice;
	NTSTATUS Status = HalGetScatterGatherList(DmaAdapter, PdoExt->FdoExtension->Device,
						  Ctx->Mdl, MmGetMdlVirtualAddress(Ctx->Mdl),
						  Srb->DataTransferLength,
						  PortStartMiniportIo,
						  Ctx, WriteToDevice);
	if (!NT_SUCCESS(Status)) {
	    goto done;
	}
    }
done:
    if (!NT_SUCCESS(Status)) {
	if (Ctx->DeallocateMdl) {
	    IoFreeMdl(Ctx->Mdl);
	}
	assert(Ctx->Srb);
	if (Ctx->Srb->MiniportContext) {
	    ExFreePoolWithTag(Ctx->Srb->MiniportContext, TAG_SRB_EXTENSION);
	}
	ExFreePoolWithTag(Ctx, TAG_PORT_CONTEXT);
	return Status;
    }
    return STATUS_SUCCESS;
}

VOID PortPdoSetBusy(IN PPDO_DEVICE_EXTENSION PdoExt)
{
    PdoExt->QueueFrozen = TRUE;
    KeClearEvent(&PdoExt->QueueUnfrozen);
}

VOID PortPdoSetReady(IN PPDO_DEVICE_EXTENSION PdoExt)
{
    PdoExt->QueueFrozen = FALSE;
    KeSetEvent(&PdoExt->QueueUnfrozen);
}

NTAPI NTSTATUS PortPdoScsi(_In_ PDEVICE_OBJECT DeviceObject,
			   _In_ PIRP Irp)
{
    DPRINT1("PortPdoScsi(%p %p)\n", DeviceObject, Irp);
    Irp->IoStatus.Information = 0;

    PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp);
    PSTORAGE_REQUEST_BLOCK Srb = Stack->Parameters.Scsi.Srb;
    PPDO_DEVICE_EXTENSION PdoExt = DeviceObject->DeviceExtension;
    ASSERT(PdoExt);
    ASSERT(PdoExt->ExtensionType == PdoExtension);
    PFDO_DEVICE_EXTENSION FdoExt = PdoExt->FdoExtension;
    ASSERT(FdoExt);
    ASSERT(FdoExt->ExtensionType == FdoExtension);

    NTSTATUS Status = STATUS_SUCCESS;
    if (!Srb) {
        DPRINT1("PortPdoScsi() called with Srb = NULL!\n");
        Status = STATUS_UNSUCCESSFUL;
	goto done;
    }

    DPRINT("Srb: %p, Srb->SrbFunction: %u\n", Srb, Srb->SrbFunction);

    UCHAR Bus = UCHAR_MAX;
    UCHAR Target = UCHAR_MAX;
    UCHAR Lun = UCHAR_MAX;
    SrbGetPathTargetLun(Srb, &Bus, &Target, &Lun);
    if (Bus != PdoExt->Bus || Target != PdoExt->Target || Lun != PdoExt->Lun) {
        DPRINT("SRB SCSI address %d:%d:%d does not match PDO %d:%d:%d\n",
	       Bus, Target, Lun, PdoExt->Bus, PdoExt->Target, PdoExt->Lun);
        Status = STATUS_NO_SUCH_DEVICE;
        Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
	goto done;
    }

    switch (Srb->SrbFunction) {
    case SRB_FUNCTION_SHUTDOWN:
	DPRINT("  SRB_FUNCTION_SHUTDOWN\n");
	goto submit;
    case SRB_FUNCTION_FLUSH:
	DPRINT("  SRB_FUNCTION_FLUSH\n");
	goto submit;
    case SRB_FUNCTION_EXECUTE_SCSI:
	DPRINT("  SRB_FUNCTION_EXECUTE_SCSI\n");
	goto submit;
    case SRB_FUNCTION_IO_CONTROL:
	DPRINT("  SRB_FUNCTION_IO_CONTROL\n");
    submit:
	/* Mark IRP as pending and start IO */
	IoMarkIrpPending(Irp);
	Status = PortStartPacket(PdoExt, Irp, Srb);
	if (!NT_SUCCESS(Status)) {
	    goto done;
	}
	return STATUS_PENDING;

    case SRB_FUNCTION_CLAIM_DEVICE:
	DPRINT("  SRB_FUNCTION_CLAIM_DEVICE\n");
	goto attach;
    case SRB_FUNCTION_ATTACH_DEVICE:
	DPRINT("  SRB_FUNCTION_ATTACH_DEVICE\n");
    attach:
	if (PdoExt->DeviceClaimed) {
	    Srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
	    Srb->SystemStatus = STATUS_DEVICE_BUSY;
	    Status = STATUS_DEVICE_BUSY;
	} else {
	    PdoExt->DeviceClaimed = TRUE;
	    Srb->SrbStatus = SRB_STATUS_SUCCESS;
	    Status = STATUS_SUCCESS;
	}
	break;

    case SRB_FUNCTION_RELEASE_DEVICE:
	DPRINT("  SRB_FUNCTION_RELEASE_DEVICE\n");
        PdoExt->DeviceClaimed = FALSE;
        Srb->SrbStatus = SRB_STATUS_SUCCESS;
	Status = STATUS_SUCCESS;
	break;

    case SRB_FUNCTION_RELEASE_QUEUE:
	DPRINT("  SRB_FUNCTION_RELEASE_QUEUE\n");
	PortPdoSetReady(PdoExt);
	Srb->SrbStatus = SRB_STATUS_SUCCESS;
	Status = STATUS_SUCCESS;
	break;

    case SRB_FUNCTION_FLUSH_QUEUE:
	DPRINT("  SRB_FUNCTION_FLUSH_QUEUE\n");
	if (!PdoExt->QueueFrozen) {
	    DPRINT("Queue is not frozen really\n");
	    Status = STATUS_INVALID_DEVICE_REQUEST;
	    break;
	}
	PortPdoSetReady(PdoExt);
	/* TODO: Check if we need to wait for the queue to become empty. */
	Status = STATUS_SUCCESS;
	break;

    default:
	DPRINT1("SRB function not implemented (Function %u)\n", Srb->SrbFunction);
	Status = STATUS_NOT_IMPLEMENTED;
	break;
    }

done:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}

NTAPI NTSTATUS PortPdoPnp(_In_ PDEVICE_OBJECT DeviceObject,
			  _In_ PIRP Irp)
{
    DPRINT1("PortPdoPnp(%p %p)\n", DeviceObject, Irp);

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}
