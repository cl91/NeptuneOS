/*
 * PROJECT:     ReactOS Storport Driver
 * LICENSE:     GPL-2.0+ (https://spdx.org/licenses/GPL-2.0+)
 * PURPOSE:     Storport PDO code
 * COPYRIGHT:   Copyright 2017 Eric Kohl (eric.kohl@reactos.org)
 */

/* INCLUDES *******************************************************************/

#include "precomp.h"
#include <stdio.h>
#include <srbhelper.h>

/* FUNCTIONS ******************************************************************/

NTSTATUS PortCreatePdo(IN PFDO_DEVICE_EXTENSION FdoDeviceExtension,
		       IN ULONG Bus,
		       IN ULONG Target,
		       IN ULONG Lun,
		       OUT PPDO_DEVICE_EXTENSION *PdoDeviceExtension)
{
    PPDO_DEVICE_EXTENSION DeviceExtension = NULL;
    PDEVICE_OBJECT Pdo = NULL;
    NTSTATUS Status;

    DPRINT("PortCreatePdo(%p %p)\n", FdoDeviceExtension, PdoDeviceExtension);

    /* Create the port device */
    Status = IoCreateDevice(FdoDeviceExtension->Device->DriverObject,
			    sizeof(PDO_DEVICE_EXTENSION), NULL, FILE_DEVICE_MASS_STORAGE,
			    FILE_DEVICE_SECURE_OPEN | FILE_AUTOGENERATED_DEVICE_NAME |
			    DO_DIRECT_IO | DO_POWER_PAGABLE,
			    FALSE, &Pdo);
    if (!NT_SUCCESS(Status)) {
	DPRINT1("IoCreateDevice() failed (Status 0x%X)\n", Status);
	return Status;
    }

    DeviceExtension = (PPDO_DEVICE_EXTENSION)Pdo->DeviceExtension;
    RtlZeroMemory(DeviceExtension, sizeof(PDO_DEVICE_EXTENSION));

    DeviceExtension->ExtensionType = PdoExtension;

    DeviceExtension->Device = Pdo;
    DeviceExtension->FdoExtension = FdoDeviceExtension;
    DeviceExtension->PnpState = dsStopped;
    KeInitializeEvent(&DeviceExtension->QueueUnfrozen, SynchronizationEvent, TRUE);

    /* Add the PDO to the PDO list*/
    InsertHeadList(&FdoDeviceExtension->PdoListHead, &DeviceExtension->PdoListEntry);
    FdoDeviceExtension->PdoCount++;

    DeviceExtension->Bus = Bus;
    DeviceExtension->Target = Target;
    DeviceExtension->Lun = Lun;

    // FIXME: More initialization

    /* The device has been initialized */
    Pdo->Flags &= ~DO_DEVICE_INITIALIZING;

    *PdoDeviceExtension = DeviceExtension;

    return STATUS_SUCCESS;
}

NTSTATUS PortDeletePdo(IN PPDO_DEVICE_EXTENSION PdoExtension)
{
    DPRINT("PortDeletePdo(%p)\n", PdoExtension);

    /* Remove the PDO from the PDO list */
    RemoveEntryList(&PdoExtension->PdoListEntry);
    PdoExtension->FdoExtension->PdoCount--;

    if (PdoExtension->InquiryBuffer) {
	ExFreePoolWithTag(PdoExtension->InquiryBuffer, TAG_INQUIRY_DATA);
	PdoExtension->InquiryBuffer = NULL;
    }

    KeClearEvent(&PdoExtension->QueueUnfrozen);

    // FIXME: More uninitialization

    /* Delete the PDO */
    IoDeleteDevice(PdoExtension->Device);

    return STATUS_SUCCESS;
}

static NTSTATUS SrbStatusToNtStatus(IN UCHAR SrbStatus)
{
    switch (SRB_STATUS(SrbStatus)) {
    case SRB_STATUS_SUCCESS:
	return STATUS_SUCCESS;
    case SRB_STATUS_BUSY:
	return STATUS_DEVICE_BUSY;
    case SRB_STATUS_INVALID_LUN:
    case SRB_STATUS_INVALID_TARGET_ID:
    case SRB_STATUS_NO_DEVICE:
    case SRB_STATUS_NO_HBA:
	return STATUS_DEVICE_DOES_NOT_EXIST;
    case SRB_STATUS_COMMAND_TIMEOUT:
    case SRB_STATUS_TIMEOUT:
	return STATUS_IO_TIMEOUT;
    case SRB_STATUS_SELECTION_TIMEOUT:
	return STATUS_DEVICE_NOT_CONNECTED;
    case SRB_STATUS_BAD_FUNCTION:
    case SRB_STATUS_BAD_SRB_BLOCK_LENGTH:
	return STATUS_INVALID_DEVICE_REQUEST;
    case SRB_STATUS_DATA_OVERRUN:
	return STATUS_BUFFER_OVERFLOW;
    default:
	return STATUS_IO_DEVICE_ERROR;
    }
}

static NTAPI VOID PortIoCompletionWorkerRoutine(IN PDEVICE_OBJECT Pdo,
						IN PVOID Context)
{
    PSRB_PORT_CONTEXT Ctx = Context;
    assert(Ctx);
    PortCompleteRequest(Ctx->Srb, FALSE);
}

VOID PortCompleteRequest(IN PSTORAGE_REQUEST_BLOCK Srb,
			 IN BOOLEAN Defer)
{
    PSRB_PORT_CONTEXT Ctx = Srb->PortContext;
    if (!Ctx) {
	assert(FALSE);
	return;
    }
    assert(Ctx->Srb == Srb);
    /* If we are not at PASSIVE_LEVEL, or caller explicitly specified deferred
     * completion, queue an IO work item so the completion is done in the main
     * event loop thread. */
    if ((!IoThreadIsAtPassiveLevel() || Defer)) {
	if (!InterlockedCompareExchange(&Ctx->CompletionQueued, 1, 0)) {
	    IoQueueWorkItem(&Ctx->CompletionWorkItem,
			    PortIoCompletionWorkerRoutine,
			    DelayedWorkQueue, Ctx);
	}
	return;
    }
    PIRP Irp = Ctx->Irp;
    assert(Irp);
    Irp->IoStatus.Status = SrbStatusToNtStatus(Srb->SrbStatus);
    if (NT_SUCCESS(Irp->IoStatus.Status)) {
	Irp->IoStatus.Information = Srb->DataTransferLength;
    }
    assert(Srb->MiniportContext);
    ExFreePoolWithTag(Srb->MiniportContext, TAG_SRB_EXTENSION);
    Srb->MiniportContext = NULL;
    Srb->PortContext = NULL;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    if (Ctx->DeallocateMdl) {
	assert(Ctx->Mdl);
	IoFreeMdl(Ctx->Mdl);
    }
    if (Ctx->SgList) {
	HalPutScatterGatherList(Ctx->DmaAdapter, Ctx->SgList, Ctx->WriteToDevice);
    }
    ExFreePoolWithTag(Ctx, TAG_PORT_CONTEXT);
}

/*
 * Set the scatter-gather list in the SRB_PORT_CONTEXT and call the
 * BuildIo and StartIo routines of the miniport.
 */
static NTAPI VOID PortStartMiniportIo(IN PDEVICE_OBJECT DeviceObject,
				      IN PSCATTER_GATHER_LIST SgList,
				      IN PVOID Context)
{
    PSRB_PORT_CONTEXT Ctx = Context;
    PSTORAGE_REQUEST_BLOCK Srb = Ctx->Srb;
    assert(Srb);
    assert(!Srb->PortContext);
    Srb->PortContext = Ctx;
    Ctx->SgList = SgList;
    PFDO_DEVICE_EXTENSION FdoExt = DeviceObject->DeviceExtension;
    assert(FdoExt->ExtensionType == FdoExtension);
    PMINIPORT Miniport = &FdoExt->Miniport;
#if DBG
    PHW_INITIALIZATION_DATA InitData = Miniport->InitData;
#endif
    assert(InitData);
    assert(InitData->HwBuildIo);
    assert(InitData->HwStartIo);
    assert(Srb->MiniportContext);
    /* Note if the miniport's BuildIo returns FALSE, it means the miniport will
     * complete it later. This is not an error, and we should not failed the SRB. */
    if (MiniportBuildIo(Miniport, Srb)) {
	if (!MiniportStartIo(Miniport, Srb)) {
	    Srb->SrbStatus = SRB_STATUS_ERROR;
	    PortCompleteRequest(Srb, TRUE);
	}
    }
}

/*
 * If the device is busy, queue the IRP. Otherwise, start the IO processing.
 */
static NTSTATUS PortStartPacket(IN OUT PPDO_DEVICE_EXTENSION PdoExt,
				IN OUT PIRP Irp,
				IN OUT PSTORAGE_REQUEST_BLOCK Srb)
{
    assert(!Srb->PortContext);
    BOOLEAN QueueFrozen = PdoExt->QueueFrozen;
    if (Srb->SrbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE) {
	/* Start IO directly without waiting for the queue to be unfrozen. */
	QueueFrozen = FALSE;
    }
    /* TODO: We need to use a device queue to save resources. Queuing on a KEVENT
     * is resource intensive since each suspended IRP takes a full coroutine stack. */
    if (QueueFrozen) {
	KeWaitForSingleObject(&PdoExt->QueueUnfrozen, Executive, KernelMode, FALSE, NULL);
    }
    /* Allocate a SRB_PORT_CONTEXT and build the scatter-gather list from the MDL.
     * If the MDL is not set (but SRB has a data buffer), build one. */
    PSRB_PORT_CONTEXT Ctx = ExAllocatePoolWithTag(NonPagedPool,
						  sizeof(SRB_PORT_CONTEXT),
						  TAG_PORT_CONTEXT);
    if (!Ctx) {
	return STATUS_INSUFFICIENT_RESOURCES;
    }
    IoInitializeWorkItem(PdoExt->Device, &Ctx->CompletionWorkItem);
    Ctx->Srb = Srb;
    Ctx->Irp = Irp;
    Ctx->DeallocateMdl = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;
    if (Irp->MdlAddress) {
	Ctx->Mdl = Irp->MdlAddress;
    } else if (Srb->DataBuffer) {
	Ctx->Mdl = IoAllocateMdl(Srb->DataBuffer, Srb->DataTransferLength);
	if (!Ctx->Mdl) {
	    ULONG64 PhyAddr = MmGetPhysicalAddress(Srb->DataBuffer).QuadPart;
	    Status = PhyAddr ? STATUS_INSUFFICIENT_RESOURCES : STATUS_INVALID_ADDRESS;
	    goto done;
	}
	Ctx->DeallocateMdl = TRUE;
    }
    assert(!Ctx->Srb->MiniportContext);
    ULONG SrbExtensionSize = PdoExt->FdoExtension->Miniport.InitData->SrbExtensionSize;
    Ctx->Srb->MiniportContext = ExAllocatePoolWithTag(CachedDmaPool,
						      SrbExtensionSize,
						      TAG_SRB_EXTENSION);
    if (!Ctx->Srb->MiniportContext) {
	goto done;
    }
    PDMA_ADAPTER DmaAdapter = PdoExt->FdoExtension->DmaAdapter;
    assert(DmaAdapter);
    if (Ctx->Mdl) {
	BOOLEAN WriteToDevice = TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_DATA_OUT);
	Ctx->DmaAdapter = DmaAdapter;
	Ctx->WriteToDevice = WriteToDevice;
	NTSTATUS Status = HalGetScatterGatherList(DmaAdapter, PdoExt->FdoExtension->Device,
						  Ctx->Mdl, MmGetMdlVirtualAddress(Ctx->Mdl),
						  Srb->DataTransferLength,
						  PortStartMiniportIo,
						  Ctx, WriteToDevice);
	if (!NT_SUCCESS(Status)) {
	    goto done;
	}
    } else {
	PortStartMiniportIo(PdoExt->FdoExtension->Device, NULL, Ctx);
    }
done:
    if (!NT_SUCCESS(Status)) {
	if (Ctx->DeallocateMdl) {
	    IoFreeMdl(Ctx->Mdl);
	}
	assert(Ctx->Srb);
	if (Ctx->Srb->MiniportContext) {
	    ExFreePoolWithTag(Ctx->Srb->MiniportContext, TAG_SRB_EXTENSION);
	}
	ExFreePoolWithTag(Ctx, TAG_PORT_CONTEXT);
	return Status;
    }
    return STATUS_SUCCESS;
}

VOID PortPdoSetBusy(IN PPDO_DEVICE_EXTENSION PdoExt)
{
    PdoExt->QueueFrozen = TRUE;
    KeClearEvent(&PdoExt->QueueUnfrozen);
}

VOID PortPdoSetReady(IN PPDO_DEVICE_EXTENSION PdoExt)
{
    PdoExt->QueueFrozen = FALSE;
    KeSetEvent(&PdoExt->QueueUnfrozen);
}

NTSTATUS PortPdoScsi(IN PDEVICE_OBJECT DeviceObject,
		     IN PIRP Irp)
{
    DPRINT1("PortPdoScsi(%p %p)\n", DeviceObject, Irp);
    Irp->IoStatus.Information = 0;

    PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp);
    PSTORAGE_REQUEST_BLOCK Srb = Stack->Parameters.Scsi.Srb;
    PPDO_DEVICE_EXTENSION PdoExt = DeviceObject->DeviceExtension;
    ASSERT(PdoExt);
    ASSERT(PdoExt->ExtensionType == PdoExtension);
#if DBG
    PFDO_DEVICE_EXTENSION FdoExt = PdoExt->FdoExtension;
    ASSERT(FdoExt);
    ASSERT(FdoExt->ExtensionType == FdoExtension);
#endif

    NTSTATUS Status = STATUS_SUCCESS;
    if (!Srb) {
        DPRINT1("PortPdoScsi() called with Srb = NULL!\n");
        Status = STATUS_UNSUCCESSFUL;
	goto done;
    }

    DPRINT("Srb: %p, Srb->SrbFunction: %u\n", Srb, Srb->SrbFunction);

    UCHAR Bus = UCHAR_MAX;
    UCHAR Target = UCHAR_MAX;
    UCHAR Lun = UCHAR_MAX;
    SrbGetPathTargetLun(Srb, &Bus, &Target, &Lun);
    if (Bus != PdoExt->Bus || Target != PdoExt->Target || Lun != PdoExt->Lun) {
        DPRINT("SRB SCSI address %d:%d:%d does not match PDO %d:%d:%d. Adjusting.\n",
	       Bus, Target, Lun, PdoExt->Bus, PdoExt->Target, PdoExt->Lun);
	SrbSetPathTargetLun(Srb, PdoExt->Bus, PdoExt->Target, PdoExt->Lun);
    }

    switch (Srb->SrbFunction) {
    case SRB_FUNCTION_SHUTDOWN:
	DPRINT("  SRB_FUNCTION_SHUTDOWN\n");
	goto submit;
    case SRB_FUNCTION_FLUSH:
	DPRINT("  SRB_FUNCTION_FLUSH\n");
	goto submit;
    case SRB_FUNCTION_EXECUTE_SCSI:
	DPRINT("  SRB_FUNCTION_EXECUTE_SCSI\n");
	goto submit;
    case SRB_FUNCTION_IO_CONTROL:
	DPRINT("  SRB_FUNCTION_IO_CONTROL\n");
    submit:
	/* Mark IRP as pending and start IO */
	IoMarkIrpPending(Irp);
	Status = PortStartPacket(PdoExt, Irp, Srb);
	if (!NT_SUCCESS(Status)) {
	    goto done;
	}
	return STATUS_PENDING;

    case SRB_FUNCTION_CLAIM_DEVICE:
	DPRINT("  SRB_FUNCTION_CLAIM_DEVICE\n");
	goto attach;
    case SRB_FUNCTION_ATTACH_DEVICE:
	DPRINT("  SRB_FUNCTION_ATTACH_DEVICE\n");
    attach:
	if (PdoExt->DeviceClaimed) {
	    Srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
	    Srb->SystemStatus = STATUS_DEVICE_BUSY;
	    Status = STATUS_DEVICE_BUSY;
	} else {
	    PdoExt->DeviceClaimed = TRUE;
	    Srb->SrbStatus = SRB_STATUS_SUCCESS;
	    Status = STATUS_SUCCESS;
	}
	break;

    case SRB_FUNCTION_RELEASE_DEVICE:
	DPRINT("  SRB_FUNCTION_RELEASE_DEVICE\n");
        PdoExt->DeviceClaimed = FALSE;
        Srb->SrbStatus = SRB_STATUS_SUCCESS;
	Status = STATUS_SUCCESS;
	break;

    case SRB_FUNCTION_RELEASE_QUEUE:
	DPRINT("  SRB_FUNCTION_RELEASE_QUEUE\n");
	PortPdoSetReady(PdoExt);
	Srb->SrbStatus = SRB_STATUS_SUCCESS;
	Status = STATUS_SUCCESS;
	break;

    case SRB_FUNCTION_FLUSH_QUEUE:
	DPRINT("  SRB_FUNCTION_FLUSH_QUEUE\n");
	if (!PdoExt->QueueFrozen) {
	    DPRINT("Queue is not frozen really\n");
	    Status = STATUS_INVALID_DEVICE_REQUEST;
	    break;
	}
	PortPdoSetReady(PdoExt);
	/* TODO: Check if we need to wait for the queue to become empty. */
	Status = STATUS_SUCCESS;
	break;

    default:
	DPRINT1("SRB function not implemented (Function %u)\n", Srb->SrbFunction);
	Status = STATUS_NOT_IMPLEMENTED;
	break;
    }

done:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}

static NTSTATUS PortPdoIoctlStorageQueryProperty(IN PPDO_DEVICE_EXTENSION PdoExt,
						 IN PFDO_DEVICE_EXTENSION FdoExt,
						 IN OUT PVOID Buffer,
						 IN ULONG InputLength,
						 IN ULONG OutputLength,
						 IN OUT PIRP Irp)
{
    PSTORAGE_PROPERTY_QUERY Query = Buffer;
    if (InputLength < FIELD_OFFSET(STORAGE_PROPERTY_QUERY, AdditionalParameters)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }
    /* For adapter description query, we forward the IRP to the FDO. */
    if (!QueryIsDeviceProperty(Query->PropertyId)) {
	IoMarkIrpPending(Irp);
	IoSkipCurrentIrpStackLocation(Irp);
	IoCallDriver(FdoExt->Device, Irp);
	return STATUS_PENDING;
    }

    switch (Query->QueryType) {
    case PropertyStandardQuery:
    {
	/* Compute the total buffer size needed */
	ULONG SizeNeeded = FIELD_OFFSET(STORAGE_DEVICE_DESCRIPTOR, RawDeviceProperties);
	PCHAR ExtraData = Buffer;
	ExtraData += SizeNeeded;
	PINQUIRYDATA InquiryData = PdoExt->InquiryBuffer;
	SizeNeeded += sizeof(InquiryData->VendorId) + sizeof(InquiryData->ProductId) +
	    sizeof(InquiryData->ProductRevisionLevel) + 3;
	/* TODO: Make VPD_SERIAL_NUMBER INQUIRY during port enumeration and return it here. */
	Irp->IoStatus.Information = SizeNeeded;
	if (OutputLength < sizeof(STORAGE_DESCRIPTOR_HEADER)) {
	    return STATUS_BUFFER_TOO_SMALL;
	}

	PSTORAGE_DEVICE_DESCRIPTOR Descriptor = Buffer;
	Descriptor->Version = sizeof(STORAGE_DEVICE_DESCRIPTOR);
	Descriptor->Size = SizeNeeded;
	if (OutputLength < SizeNeeded) {
	    /* Based on the behavior of the classpnp.sys driver, we should return success
	     * here rather than STATUS_BUFFER_TOO_SMALL. */
	    return STATUS_SUCCESS;
	}

	Descriptor->DeviceType = InquiryData->DeviceType;
	Descriptor->DeviceTypeModifier = InquiryData->DeviceTypeModifier;
	Descriptor->RemovableMedia = InquiryData->RemovableMedia;
	Descriptor->CommandQueueing = InquiryData->CommandQueue;
	Descriptor->BusType = FdoExt->DriverExtension->StorageBusType;

	RtlCopyMemory(ExtraData, InquiryData->VendorId, sizeof(InquiryData->VendorId));
	ExtraData += sizeof(InquiryData->VendorId);
	*ExtraData++ = '\0';
	Descriptor->VendorIdOffset = FIELD_OFFSET(STORAGE_DEVICE_DESCRIPTOR,
						  RawDeviceProperties);

	RtlCopyMemory(ExtraData, InquiryData->ProductId, sizeof(InquiryData->ProductId));
	ExtraData += sizeof(InquiryData->ProductId);
	*ExtraData++ = '\0';
	Descriptor->ProductIdOffset = Descriptor->VendorIdOffset +
	    sizeof(InquiryData->VendorId) + 1;

	RtlCopyMemory(ExtraData, InquiryData->ProductRevisionLevel,
		      sizeof(InquiryData->ProductRevisionLevel));
	ExtraData += sizeof(InquiryData->ProductRevisionLevel);
	*ExtraData++ = '\0';
	Descriptor->ProductRevisionOffset = Descriptor->ProductIdOffset +
	    sizeof(InquiryData->ProductId) + 1;

	return STATUS_SUCCESS;
    }

    case PropertyExistsQuery:
	return STATUS_SUCCESS;

    default:
	return STATUS_INVALID_DEVICE_REQUEST;
    }
}

/*
 * Pass the request to the FDO
 */
static NTSTATUS PortPdoIoctlScsiPassThrough(IN PPDO_DEVICE_EXTENSION PdoExt,
					    IN PFDO_DEVICE_EXTENSION FdoExt,
					    IN OUT PVOID Buffer,
					    IN ULONG InputLength,
					    IN PIRP Irp)
{
    if (InputLength < sizeof(SCSI_PASS_THROUGH)) {
        return STATUS_BUFFER_TOO_SMALL;
    }
    PSCSI_PASS_THROUGH Command = Buffer;
    Command->PathId = PdoExt->Bus;
    Command->TargetId = PdoExt->Target;
    Command->Lun = PdoExt->Lun;
    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(FdoExt->Device, Irp);
}

static NTSTATUS PortPdoIoctlScsiGetAddress(IN PPDO_DEVICE_EXTENSION PdoExt,
					   IN PFDO_DEVICE_EXTENSION FdoExt,
					   IN OUT PVOID Buffer,
					   IN ULONG OutputLength,
					   OUT PULONG_PTR Information)
{
    if (OutputLength < sizeof(SCSI_ADDRESS)) {
        return STATUS_BUFFER_TOO_SMALL;
    }
    PSCSI_ADDRESS ScsiAddress = Buffer;
    ScsiAddress->Length = sizeof (SCSI_ADDRESS);
    ScsiAddress->PortNumber = FdoExt->PortNumber;
    ScsiAddress->PathId = PdoExt->Bus;
    ScsiAddress->TargetId = PdoExt->Target;
    ScsiAddress->Lun = PdoExt->Lun;
    *Information = sizeof(SCSI_ADDRESS);
    return STATUS_SUCCESS;
}

NTSTATUS PortPdoDeviceControl(IN PDEVICE_OBJECT DeviceObject,
			      IN PIRP Irp)
{
    DPRINT1("PortPdoDeviceControl(%p %p)\n", DeviceObject, Irp);
    Irp->IoStatus.Information = 0;

    PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp);
    ULONG Ioctl = Stack->Parameters.DeviceIoControl.IoControlCode;
    PPDO_DEVICE_EXTENSION PdoExt = DeviceObject->DeviceExtension;
    ASSERT(PdoExt);
    ASSERT(PdoExt->ExtensionType == PdoExtension);
    PFDO_DEVICE_EXTENSION FdoExt = PdoExt->FdoExtension;
    ASSERT(FdoExt);
    ASSERT(FdoExt->ExtensionType == FdoExtension);
#if DBG
    PMINIPORT Miniport = &FdoExt->Miniport;
    assert(Miniport);
    assert(Miniport->InitData);
    assert(Miniport->MiniportExtension);
#endif

    /* All of the IOCTLs we handle are METHOD_BUFFERED IOCTLs */
    PVOID Buffer = Irp->SystemBuffer;
    ULONG InputLength = Stack->Parameters.DeviceIoControl.InputBufferLength;
    ULONG OutputLength = Stack->Parameters.DeviceIoControl.OutputBufferLength;

    NTSTATUS Status = STATUS_NOT_SUPPORTED;

    switch (Ioctl) {
    case IOCTL_STORAGE_QUERY_PROPERTY:
	DPRINT1("IRP_MJ_DEVICE_CONTROL / IOCTL_STORAGE_QUERY_PROPERTY\n");
	Status = PortPdoIoctlStorageQueryProperty(PdoExt, FdoExt, Buffer,
						  InputLength, OutputLength, Irp);
	break;

    case IOCTL_SCSI_PASS_THROUGH:
	DPRINT1("IRP_MJ_DEVICE_CONTROL / IOCTL_SCSI_PASS_THROUGH\n");
	Status = PortPdoIoctlScsiPassThrough(PdoExt, FdoExt, Buffer, InputLength, Irp);
	break;

    case IOCTL_SCSI_PASS_THROUGH_DIRECT:
	DPRINT1("IRP_MJ_DEVICE_CONTROL / IOCTL_SCSI_PASS_THROUGH_DIRECT\n");
	Status = PortPdoIoctlScsiPassThrough(PdoExt, FdoExt, Buffer, InputLength, Irp);
	break;

    case IOCTL_SCSI_GET_ADDRESS:
	DPRINT1("IRP_MJ_DEVICE_CONTROL / IOCTL_SCSI_GET_ADDRESS\n");
	Status = PortPdoIoctlScsiGetAddress(PdoExt, FdoExt, Buffer, OutputLength,
					    &Irp->IoStatus.Information);
	break;
    }

    Irp->IoStatus.Status = Status;
    if (Status != STATUS_PENDING) {
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    return Status;
}

static NTSTATUS PortPdoStartDevice(IN PPDO_DEVICE_EXTENSION DevExt,
				   IN PIRP Irp)
{
    return STATUS_SUCCESS;
}

static NTSTATUS PortPdoQueryTargetDeviceRelation(IN PPDO_DEVICE_EXTENSION DevExt,
						 OUT PULONG_PTR Information)
{
    DPRINT1("PortPdoQueryTargetDeviceRelation(%p %p)\n", DevExt, Information);

    PDEVICE_RELATIONS DeviceRelations = ExAllocatePoolWithTag(NonPagedPool,
							      sizeof(DEVICE_RELATIONS) +
							      sizeof(PDEVICE_OBJECT),
							      TAG_DEV_RELATIONS);
    if (!DeviceRelations) {
        return STATUS_NO_MEMORY;
    }
    DeviceRelations->Objects[0] = DevExt->Device;
    DeviceRelations->Count = 1;
    *Information = (ULONG_PTR)DeviceRelations;
    return STATUS_SUCCESS;
}

#define QUERY_ID_BUFSIZE	512

static PCSTR ScsiDeviceTypeStrings[][2] = {
    { "Disk",        "GenDisk" },
    { "Sequential",  "" },
    { "Printer",     "GenPrinter" },
    { "Processor",   "" },
    { "Worm",        "GenWorm" },
    { "CdRom",       "GenCdRom" },
    { "Scanner",     "GenScanner" },
    { "Optical",     "GenOptical" },
    { "Changer",     "ScsiChanger" },
    { "Net",         "ScsiNet" },
    { "ASCIT8",      "ScsiASCIT8" },
    { "ASCIT8",      "ScsiASCIT8" },
    { "Array",       "ScsiArray" },
    { "Enclosure",   "ScsiEnclosure" },
    { "RBC",         "ScsiRBC" },
    { "CardReader",  "ScsiCardReader" },
    { "Bridge",      "ScsiBridge" },
    { "Other",       "ScsiOther" },
};

static PCSTR StorGetDeviceTypeString(IN UCHAR DeviceType)
{
    if (DeviceType > ARRAYSIZE(ScsiDeviceTypeStrings)) {
	return "Invalid";
    }
    return ScsiDeviceTypeStrings[DeviceType][0];
}

static PCSTR StorGetDeviceTypeGenericName(IN UCHAR DeviceType)
{
    if (DeviceType > ARRAYSIZE(ScsiDeviceTypeStrings)) {
	return "InvalidDeviceType";
    }
    return ScsiDeviceTypeStrings[DeviceType][1];
}

#define INQUIRY_ID_BUFSIZE	32

static VOID StorSanitizeInquiryId(IN UCHAR InquiryId[],
				  OUT CHAR Id[INQUIRY_ID_BUFSIZE],
				  IN ULONG IdSize,
				  IN UCHAR ReplacementChar)
{
    assert((IdSize + 1) < INQUIRY_ID_BUFSIZE);
    RtlCopyMemory(Id, InquiryId, IdSize);
    for (ULONG i = strlen(Id); i; i--) {
	if (Id[i-1] != ' ') {
	    break;
	}
	Id[i-1] = ReplacementChar;
    }
    for (ULONG i = strlen(Id); i < IdSize; i++) {
	Id[i] = ReplacementChar;
    }
    Id[IdSize] = '\0';
}

/*
 * Returns the device ID of the PDO.
 *
 * Example: SCSI\Disk&Ven_QEMU&Prod_HARDDISK&Rev_2.5+
 */
static VOID StorPdoGetDeviceId(IN PPDO_DEVICE_EXTENSION DevExt,
			       OUT PWSTR Id)
{
    assert(DevExt->InquiryBuffer);
    CHAR VendorId[INQUIRY_ID_BUFSIZE] = {};
    CHAR ProductId[INQUIRY_ID_BUFSIZE] = {};
    CHAR ProductRevisionLevel[INQUIRY_ID_BUFSIZE] = {};
    StorSanitizeInquiryId(DevExt->InquiryBuffer->VendorId, VendorId,
			  sizeof(DevExt->InquiryBuffer->VendorId), '\0');
    StorSanitizeInquiryId(DevExt->InquiryBuffer->ProductId, ProductId,
			  sizeof(DevExt->InquiryBuffer->ProductId), '\0');
    StorSanitizeInquiryId(DevExt->InquiryBuffer->ProductRevisionLevel, ProductRevisionLevel,
			  sizeof(DevExt->InquiryBuffer->ProductRevisionLevel), '\0');
    _snwprintf(Id, QUERY_ID_BUFSIZE,
	       L"SCSI\\%hs&Ven_%hs&Prod_%hs&Rev_%hs",
	       StorGetDeviceTypeString(DevExt->InquiryBuffer->DeviceType),
	       VendorId,
	       ProductId,
	       ProductRevisionLevel);
}

static VOID StorPdoGetInstanceId(IN PPDO_DEVICE_EXTENSION DevExt,
				 OUT PWSTR Id)
{
    _snwprintf(Id, QUERY_ID_BUFSIZE, L"%x%x%x",
	       DevExt->Bus, DevExt->Target, DevExt->Lun);
}

static VOID StorPdoGetHardwareIds(IN PPDO_DEVICE_EXTENSION DevExt,
				  OUT PWSTR Id)
{
    PINQUIRYDATA InquiryData = DevExt->InquiryBuffer;
    PCSTR DeviceType = StorGetDeviceTypeString(InquiryData->DeviceType);
    PCSTR GenericName = StorGetDeviceTypeGenericName(InquiryData->DeviceType);
    CHAR VendorId[INQUIRY_ID_BUFSIZE] = {};
    CHAR ProductId[INQUIRY_ID_BUFSIZE] = {};
    CHAR ProductRevisionLevel[INQUIRY_ID_BUFSIZE] = {};
    StorSanitizeInquiryId(InquiryData->VendorId, VendorId,
			  sizeof(InquiryData->VendorId), '_');
    StorSanitizeInquiryId(InquiryData->ProductId, ProductId,
			  sizeof(InquiryData->ProductId), '_');
    StorSanitizeInquiryId(InquiryData->ProductRevisionLevel, ProductRevisionLevel,
			  sizeof(InquiryData->ProductRevisionLevel), '_');

    /*
     * SCSI\<DEVICE><VENDOR><PRODUCT><REVISION>
     *
     * Example: SCSI\DiskQEMU____HARDDISK________2.5+
     */
    ULONG RemainingSize = QUERY_ID_BUFSIZE - 1;
    ULONG WcharsWritten = _snwprintf(Id, RemainingSize,
				     L"SCSI\\%hs%hs%hs%hs",
				     DeviceType,
				     VendorId,
				     ProductId,
				     ProductRevisionLevel) + 1;
    Id += WcharsWritten;
    assert(RemainingSize >= WcharsWritten * sizeof(WCHAR));
    RemainingSize -= WcharsWritten * sizeof(WCHAR);
    if (RemainingSize <= 1) {
	goto out;
    }

    /*
     * SCSI\<DEVICE><VENDOR><PRODUCT>
     *
     * Example: SCSI\DiskQEMU____HARDDISK________
     */
    WcharsWritten = _snwprintf(Id, RemainingSize,
			       L"SCSI\\%hs%hs%hs",
			       DeviceType,
			       VendorId,
			       ProductId) + 1;
    Id += WcharsWritten;
    assert(RemainingSize >= WcharsWritten * sizeof(WCHAR));
    RemainingSize -= WcharsWritten * sizeof(WCHAR);
    if (RemainingSize <= 1) {
	goto out;
    }

    /*
     * SCSI\<DEVICE><VENDOR>
     *
     * Example: SCSI\DiskQEMU____
     */
    WcharsWritten = _snwprintf(Id, RemainingSize,
			       L"SCSI\\%hs%hs",
			       DeviceType,
			       VendorId) + 1;
    Id += WcharsWritten;
    assert(RemainingSize >= WcharsWritten * sizeof(WCHAR));
    RemainingSize -= WcharsWritten * sizeof(WCHAR);
    if (RemainingSize <= 1) {
	goto out;
    }

    /*
     * SCSI\<VENDOR><PRODUCT><REVISION[0]>
     *
     * Example: SCSI\QEMU____HARDDISK________2
     */
    WcharsWritten = _snwprintf(Id, RemainingSize,
			       L"SCSI\\%hs%hs%hc",
			       VendorId,
			       ProductId,
			       ProductRevisionLevel[0]) + 1;
    Id += WcharsWritten;
    assert(RemainingSize >= WcharsWritten * sizeof(WCHAR));
    RemainingSize -= WcharsWritten * sizeof(WCHAR);
    if (RemainingSize <= 1) {
	goto out;
    }

    /*
     * <VENDOR><PRODUCT><REVISION[0]>
     *
     * Example: QEMU____HARDDISK________2
     */
    WcharsWritten = _snwprintf(Id, RemainingSize,
			       L"%hs%hs%hc",
			       VendorId,
			       ProductId,
			       ProductRevisionLevel[0]) + 1;
    Id += WcharsWritten;
    assert(RemainingSize >= WcharsWritten * sizeof(WCHAR));
    RemainingSize -= WcharsWritten * sizeof(WCHAR);
    if (RemainingSize <= 1) {
	goto out;
    }

    /*
     * <GenericName>
     *
     * Example: GenDisk
     */
    WcharsWritten = _snwprintf(Id, RemainingSize,
			       L"%hs",
			       GenericName) + 1;
    Id += WcharsWritten;
    assert(RemainingSize >= WcharsWritten * sizeof(WCHAR));

out:
    *Id++ = UNICODE_NULL;
}

static PCSTR StorageBusTypeStrings[] = {
    "Unknown",
    "Scsi",
    "Atapi",
    "Ata",
    "1394",
    "Ssa",
    "Fibre",
    "Usb",
    "RAID",
    "iScsi",
    "Sas",
    "Sata",
    "Sd",
    "Mmc",
    "Virtual",
    "FileBackedVirtual",
    "Spaces",
    "Nvme",
    "SCM",
    "Invalid"
};

static PCSTR StorGetStorageBusTypeString(IN PPDO_DEVICE_EXTENSION DevExt)
{
    PDRIVER_OBJECT_EXTENSION DrvExt = DevExt->FdoExtension->DriverExtension;
    if ((ULONG)DrvExt->StorageBusType >= (ULONG)BusTypeMax) {
	return "Invalid";
    }
    return StorageBusTypeStrings[DrvExt->StorageBusType];
}

static VOID StorPdoGetCompatibleIds(IN PPDO_DEVICE_EXTENSION DevExt,
				    OUT PWSTR Id)
{
    PINQUIRYDATA InquiryData = DevExt->InquiryBuffer;
    PCSTR DeviceType = StorGetDeviceTypeString(InquiryData->DeviceType);

    /*
     * SCSI\<DEVICE>
     */
    ULONG RemainingSize = QUERY_ID_BUFSIZE - 1;
    ULONG WcharsWritten = _snwprintf(Id, RemainingSize,
				     L"SCSI\\%hs",
				     DeviceType) + 1;
    Id += WcharsWritten;
    assert(RemainingSize >= WcharsWritten * sizeof(WCHAR));
    RemainingSize -= WcharsWritten * sizeof(WCHAR);
    if (RemainingSize <= 1) {
	goto out;
    }

    /*
     * SCSI\<StorageBusType>
     *
     * Example: SCSI\Sata
     */
    WcharsWritten = _snwprintf(Id, RemainingSize,
			       L"SCSI\\%hs",
			       StorGetStorageBusTypeString(DevExt)) + 1;
    Id += WcharsWritten;
    assert(RemainingSize >= WcharsWritten * sizeof(WCHAR));
    RemainingSize -= WcharsWritten * sizeof(WCHAR);
    if (RemainingSize <= 1) {
	goto out;
    }

    /*
     * SCSI\<StorageBusType><DEVICE>
     *
     * Example: SCSI\Sata
     */
    WcharsWritten = _snwprintf(Id, RemainingSize,
			       L"SCSI\\%hs%hs",
			       StorGetStorageBusTypeString(DevExt),
			       DeviceType) + 1;
    Id += WcharsWritten;
    assert(RemainingSize >= WcharsWritten * sizeof(WCHAR));
    RemainingSize -= WcharsWritten * sizeof(WCHAR);
    if (RemainingSize <= 1) {
	goto out;
    }

    /*
     * SCSI\RAW
     */
    WcharsWritten = _snwprintf(Id, RemainingSize,
			       L"SCSI\\RAW") + 1;
    Id += WcharsWritten;

out:
    *Id++ = UNICODE_NULL;
}

static NTSTATUS PortPdoQueryId(IN PPDO_DEVICE_EXTENSION DevExt,
			       IN BUS_QUERY_ID_TYPE IdType,
			       OUT PULONG_PTR Information)
{
    DPRINT1("PortPdoQueryId(%p %d %p)\n", DevExt, IdType, Information);

    assert(DevExt->InquiryBuffer);
    if (!DevExt->InquiryBuffer) {
	*Information = 0;
	return STATUS_INVALID_DEVICE_REQUEST;
    }

    PWSTR Id = ExAllocatePool(NonPagedPool, QUERY_ID_BUFSIZE);
    if (!Id) {
	*Information = 0;
	return STATUS_INSUFFICIENT_RESOURCES;
    }

    switch (IdType) {
    case BusQueryDeviceID:
	StorPdoGetDeviceId(DevExt, Id);
	break;
    case BusQueryInstanceID:
	StorPdoGetInstanceId(DevExt, Id);
	break;
    case BusQueryHardwareIDs:
	StorPdoGetHardwareIds(DevExt, Id);
	break;
    case BusQueryCompatibleIDs:
	StorPdoGetCompatibleIds(DevExt, Id);
	break;
    default:
	ExFreePool(Id);
	Id = NULL;
    }

    *Information = (ULONG_PTR)Id;
    return STATUS_SUCCESS;
}

NTSTATUS PortPdoPnp(IN PDEVICE_OBJECT DeviceObject,
		    IN PIRP Irp)
{
    DPRINT1("PortPdoPnp(%p %p)\n", DeviceObject, Irp);

    PPDO_DEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(DeviceExtension);
    ASSERT(DeviceExtension->ExtensionType == PdoExtension);

    PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp);

    ULONG_PTR Information = 0;
    NTSTATUS Status = STATUS_NOT_SUPPORTED;

    switch (Stack->MinorFunction) {
    case IRP_MN_START_DEVICE: /* 0x00 */
	DPRINT1("IRP_MJ_PNP / IRP_MN_START_DEVICE\n");
	Status = PortPdoStartDevice(DeviceExtension, Irp);
	break;

    case IRP_MN_QUERY_REMOVE_DEVICE: /* 0x01 */
	DPRINT1("IRP_MJ_PNP / IRP_MN_QUERY_REMOVE_DEVICE\n");
	break;

    case IRP_MN_REMOVE_DEVICE: /* 0x02 */
	DPRINT1("IRP_MJ_PNP / IRP_MN_REMOVE_DEVICE\n");
	break;

    case IRP_MN_CANCEL_REMOVE_DEVICE: /* 0x03 */
	DPRINT1("IRP_MJ_PNP / IRP_MN_CANCEL_REMOVE_DEVICE\n");
	break;

    case IRP_MN_STOP_DEVICE: /* 0x04 */
	DPRINT1("IRP_MJ_PNP / IRP_MN_STOP_DEVICE\n");
	break;

    case IRP_MN_QUERY_STOP_DEVICE: /* 0x05 */
	DPRINT1("IRP_MJ_PNP / IRP_MN_QUERY_STOP_DEVICE\n");
	break;

    case IRP_MN_CANCEL_STOP_DEVICE: /* 0x06 */
	DPRINT1("IRP_MJ_PNP / IRP_MN_CANCEL_STOP_DEVICE\n");
	break;

    case IRP_MN_QUERY_DEVICE_RELATIONS: /* 0x07 */
	DPRINT1("IRP_MJ_PNP / IRP_MN_QUERY_DEVICE_RELATIONS\n");
	switch (Stack->Parameters.QueryDeviceRelations.Type) {
	case TargetDeviceRelation:
	    DPRINT1("    IRP_MJ_PNP / IRP_MN_QUERY_DEVICE_RELATIONS / TargetDeviceRelation\n");
	    Status = PortPdoQueryTargetDeviceRelation(DeviceExtension, &Information);
	    break;

	default:
	    DPRINT1("    IRP_MJ_PNP / IRP_MN_QUERY_DEVICE_RELATIONS / Unsupported type "
		    "0x%x\n",
		    Stack->Parameters.QueryDeviceRelations.Type);
	}
	break;

    case IRP_MN_QUERY_RESOURCES: /* 0x0a */
	DPRINT1("IRP_MJ_PNP / IRP_MN_QUERY_RESOURCES\n");
	Status = STATUS_SUCCESS;
	break;

    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS: /* 0x0b */
	DPRINT1("IRP_MJ_PNP / IRP_MN_QUERY_RESOURCE_REQUIREMENTS\n");
	Status = STATUS_SUCCESS;
	break;

    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS: /* 0x0d */
	DPRINT1("IRP_MJ_PNP / IRP_MN_FILTER_RESOURCE_REQUIREMENTS\n");
	break;

    case IRP_MN_QUERY_ID: /* 0x13 */
	DPRINT1("IRP_MJ_PNP / IRP_MN_QUERY_ID\n");
	Status = PortPdoQueryId(DeviceExtension,
				Stack->Parameters.QueryId.IdType,
				&Information);
	break;

    case IRP_MN_QUERY_PNP_DEVICE_STATE: /* 0x14 */
	DPRINT1("IRP_MJ_PNP / IRP_MN_QUERY_PNP_DEVICE_STATE\n");
	break;

    case IRP_MN_QUERY_BUS_INFORMATION: /* 0x15 */
	DPRINT1("IRP_MJ_PNP / IRP_MN_QUERY_BUS_INFORMATION\n");
	break;

    case IRP_MN_DEVICE_USAGE_NOTIFICATION: /* 0x16 */
	DPRINT1("IRP_MJ_PNP / IRP_MN_DEVICE_USAGE_NOTIFICATION\n");
	break;

    case IRP_MN_SURPRISE_REMOVAL: /* 0x17 */
	DPRINT1("IRP_MJ_PNP / IRP_MN_SURPRISE_REMOVAL\n");
	break;

    default:
	DPRINT1("IRP_MJ_PNP / Unknown minor code 0x%x\n", Stack->MinorFunction);
	break;
    }

    Irp->IoStatus.Information = Information;
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}
