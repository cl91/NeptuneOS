/*
 * PNP Root Enumerator (Root Bus) Driver
 *
 * This driver implements the root bus, also known as the root enumerator,
 * of the Plug and Play subsystem. On Windows this is part of the NTOSKRNL
 * PNP manager, whereas here in NeptuneOS the root bus is a standard PNP
 * driver that implements the PNP bus driver interface.
 */

#include <assert.h>
#include <wdm.h>

#define PNP_ROOT_ENUMERATOR_U	L"\\Device\\pnp"

static NTSTATUS PnpRootQueryDeviceRelations(IN PDEVICE_OBJECT DeviceObject,
					    IN PIRP Irp)
{
    DPRINT("PnpRootQueryDeviceRelations(FDO %p, Irp %p)\n",
	   DeviceObject, Irp);

    PIO_STACK_LOCATION IoSp = IoGetCurrentIrpStackLocation(Irp);
    if (IoSp->Parameters.QueryDeviceRelations.Type != BusRelations) {
	return STATUS_INVALID_PARAMETER;
    }

    ULONG Size = sizeof(DEVICE_RELATIONS) + sizeof(PDEVICE_OBJECT);
    PDEVICE_RELATIONS Relations = (PDEVICE_RELATIONS)ExAllocatePool(Size);
    NTSTATUS Status;
    if (!Relations) {
	DPRINT("ExAllocatePool() failed\n");
	Status = STATUS_NO_MEMORY;
	goto out;
    }

    /* For now we simply hard-code the only device that we will create:
     * the PS/2 keyboard. */
    PDEVICE_OBJECT Pdo = NULL;
    Status = IoCreateDevice(DeviceObject->DriverObject, 0, NULL,
			    FILE_DEVICE_8042_PORT,
			    FILE_AUTOGENERATED_DEVICE_NAME,
			    FALSE, &Pdo);
    if (!NT_SUCCESS(Status)) {
	DPRINT("IoCreateDevice() failed with status 0x%08x\n",
	       Status);
	goto out;
    }
    Relations->Count = 1;
    Relations->Objects[0] = Pdo;
    Irp->IoStatus.Information = (ULONG_PTR)Relations;
    Status = STATUS_SUCCESS;

out:
    if (!NT_SUCCESS(Status)) {
	if (Relations)
	    ExFreePool(Relations);
	if (Pdo) {
	    IoDeleteDevice(Pdo);
	}
    }

    return Status;
}

static NTSTATUS PnpRootQueryCapabilities(IN PDEVICE_OBJECT DeviceObject,
					 IN PIRP Irp)
{
    return STATUS_NOT_IMPLEMENTED;
}

static NTSTATUS PnpRootRemoveDevice(IN PDEVICE_OBJECT DeviceObject,
				    IN PIRP Irp)
{
    return STATUS_NOT_IMPLEMENTED;
}

static NTSTATUS PnpRootQueryPnpDeviceState(IN PDEVICE_OBJECT DeviceObject,
					   IN PIRP Irp)
{
    return STATUS_NOT_IMPLEMENTED;
}

static NTSTATUS PnpRootQueryResources(IN PDEVICE_OBJECT DeviceObject,
				      IN PIRP Irp)
{
    return STATUS_NOT_IMPLEMENTED;
}

static NTSTATUS PnpRootQueryResourceRequirements(IN PDEVICE_OBJECT DeviceObject,
						 IN PIRP Irp)
{
    return STATUS_NOT_IMPLEMENTED;
}

static NTSTATUS PnpRootQueryId(IN PDEVICE_OBJECT DeviceObject,
			       IN PIRP Irp)
{
    return STATUS_NOT_IMPLEMENTED;
}

static NTSTATUS PnpRootQueryDeviceText(IN PDEVICE_OBJECT DeviceObject,
				       IN PIRP Irp)
{
    return STATUS_NOT_IMPLEMENTED;
}

static NTSTATUS PnpRootFilterResourceRequirements(IN PDEVICE_OBJECT DeviceObject,
						  IN PIRP Irp)
{
    return STATUS_NOT_IMPLEMENTED;
}

static NTSTATUS PnpRootQueryBusInformation(IN PDEVICE_OBJECT DeviceObject,
					   IN PIRP Irp)
{
    return STATUS_NOT_IMPLEMENTED;
}

static NTSTATUS PnpRootQueryDeviceUsageNotification(IN PDEVICE_OBJECT DeviceObject,
						    IN PIRP Irp)
{
    return STATUS_NOT_IMPLEMENTED;
}

NTAPI NTSTATUS PnpDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS Status;
    switch (IrpSp->MinorFunction) {
    case IRP_MN_START_DEVICE:
	Status = STATUS_SUCCESS;
	break;

    case IRP_MN_STOP_DEVICE:
	Status = STATUS_SUCCESS;
	break;

    case IRP_MN_QUERY_STOP_DEVICE:
	Status = STATUS_SUCCESS;
	break;

    case IRP_MN_QUERY_REMOVE_DEVICE:
	Status = STATUS_SUCCESS;
	break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:
	Status = PnpRootQueryDeviceRelations(DeviceObject, Irp);
	break;

    case IRP_MN_QUERY_CAPABILITIES:
	Status = PnpRootQueryCapabilities(DeviceObject, Irp);
	break;

    case IRP_MN_SURPRISE_REMOVAL:
	Status = PnpRootRemoveDevice(DeviceObject, Irp);
	break;

    case IRP_MN_REMOVE_DEVICE:
	Status = PnpRootRemoveDevice(DeviceObject, Irp);
	break;

    case IRP_MN_QUERY_PNP_DEVICE_STATE:
	Status = PnpRootQueryPnpDeviceState(DeviceObject, Irp);
	break;

    case IRP_MN_QUERY_RESOURCES:
	Status = PnpRootQueryResources(DeviceObject, Irp);
	break;

    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
	Status = PnpRootQueryResourceRequirements(DeviceObject, Irp);
	break;

    case IRP_MN_QUERY_ID:
	Status = PnpRootQueryId(DeviceObject, Irp);
	break;

    case IRP_MN_QUERY_DEVICE_TEXT:
	Status = PnpRootQueryDeviceText(DeviceObject, Irp);
	break;

    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
	Status = PnpRootFilterResourceRequirements(DeviceObject, Irp);
	break;

    case IRP_MN_QUERY_BUS_INFORMATION:
	Status = PnpRootQueryBusInformation(DeviceObject, Irp);
	break;

    case IRP_MN_DEVICE_USAGE_NOTIFICATION:
	Status = PnpRootQueryDeviceUsageNotification(DeviceObject, Irp);
	break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
	Status = STATUS_SUCCESS;
	break;

    default:
	DPRINT("Unknown PnP code: %X\n", IrpSp->MinorFunction);
	break;
    }

    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}

NTAPI NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject,
			   IN PUNICODE_STRING RegistryPath)
{
    UNREFERENCED_PARAMETER(RegistryPath);

    /* Create the root enumerator device object */
    UNICODE_STRING DeviceName = RTL_CONSTANT_STRING(PNP_ROOT_ENUMERATOR_U);
    PDEVICE_OBJECT RootEnumerator;
    NTSTATUS Status = IoCreateDevice(DriverObject, 0, &DeviceName,
				     FILE_DEVICE_BUS_EXTENDER, 0, FALSE,
				     &RootEnumerator);

    if (!NT_SUCCESS(Status))
	return Status;

    DriverObject->MajorFunction[IRP_MJ_PNP] = PnpDispatch;

    return STATUS_SUCCESS;
}
